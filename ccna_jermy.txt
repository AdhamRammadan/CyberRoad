      ██████╗░░██████╗░░██╗░░░░░░██╗░██╗░░░░██╗░██╗░░██████╗░░████╗░░░██╗
     ██╔═══██╗░██╗░░██░░██║░░░░░░░░░░██║░░░ ██║░░░░░██╔═══██╗░██║██╗░░██║
     ██║░░░██║░██████╗░░██║░░░░░░██╗░░██╗░░██╗░░██╗░██║░░░██║░██║░██╗░██║
     ██║░░░██║░██║░░██░░██║░░░░░░██║░░░██║██║░░░██║░██║░░░██║░██║░░██╗██╝
      ██████╔╝░███████╗░███████╗░██║░░░░███╗░░░░██║░╚██████╔╝░██║░░░███╗░
      ╚═════╝░░╚══════╝░╚══════╝░╚═╝░░░░╚══╝░░░░╚═╝░░╚════╝░░░╚═╝░░░╚══╝░


Initials:
    Computer network: A digital telecomunication network which allow nodes(R, SW, FW, (SR, and client)[endhosts/enpoints]) to share resources
    Network Interface Card (NIC): A NIC physically connects the end device to the network.
    Physical Port: A connector or outlet on a networking device where the media connects to an end device or another networking device.
        Interface: Specialized ports on a networking device that connect to individual networks. Because Rs connect networks, the ports on a R are referred to as network interfaces.

    Home and Small Office Internet Connections
    Cable:  cable television service providers, the internet data signal transmits on the same television cable. 
        high bandwidth, high availability, and an always-on connection to the internet.
    DSL:    Digital Subscriber Lines, high bandwidth, high availability, and an always-on connection to the internet. 
        runs over a telephone line. In general, connect using Asymmetrical DSL (ADSL), means the download speed is faster than the upload speed.
    Cellular:   uses a cell phone network to connect. Performance is limited by the capabilities of the phone and the cell tower to which it is connected.
    Satellite:  The availability benefits in those areas that would otherwise have no internet connectivity at all. Require a clear line of sight to the satellite.
    Dial-up Telephone:  uses any phone line and a modem. Low bandwidth not sufficient for large data transfer, although it is useful for mobile access while traveling.

    Businesses Internet Connections
    Dedicated Leased Line:  Reserved circuits within the service provider’s network that connect geographically separated offices for private voice and/or data networking. 
        The circuits are rented at a monthly or yearly rate.
    Metro Ethernet: This known as Ethernet WAN. Metro ethernets extend LAN access technology into the WAN. Ethernet is a LAN technology.
    Business DSL:   available in various formats. A popular choice is Symmetric Digital Subscriber Line (SDSL) similar to the consumer DSL 
        but provides uploads and downloads at the same high speeds.
    Satellite:  can provide a connection when a wired solution is not available.

    Converged Networks: networks are capable of delivering data, voice, and video between many different types of devices over the same network infrastructure. 
        This network infrastructure uses the same set of rules, agreements, and implementation standards. 
    Converged data networks: carry multiple services on one network.
    attenuation: loss of signal strength as distance increases

    Confidentiality: only the intended and authorized recipients can access and read data.
    Integrity: assures that the information has not been altered in transmission, from origin to destination.
    Availability: assures reliable access to data services for authorized users.

    Cloud Types
    Public clouds: Available to the general population. Free or pay-per-use model. Uses the internet to provide services.
    Private clouds: intended for a specific Org or entity. Can be set up using the Org’s private network. Can also be managed by an outside Org with strict access security.
    Hybrid clouds: made up of two or more clouds, where each part remains a distinct object, but both are connected using a single architecture. 
        Individuals on a hybrid cloud would be able to have degrees of access to various services based on user access rights.
    Community clouds: 
        Used by multiple Orgs that have similar needs and concerns. Are similar to a public, but with set levels of security, privacy, and even regulatory compliance of a private cloud.

    Viruses, worms, and Trojan horses:  malicious software or code running on a user device.
    Spyware and adware: Installed software that secretly collects information about the user.
    Zero-day attacks:   Also called zero-hour attacks, these occur on the first day that a vulnerability becomes known.
    Threat actor attacks:   A malicious person attacks devices or network resources.
    Denial of service attacks:  slow or crash applications and processes on a network device.
    Data interception and theft:    captures private information from an Org’s network.
    Identity theft: steals the login credentials of a user in order to access private data.

    Dedicated firewall systems: advanced firewall capabilities that can filter large amounts of traffic with more granularity.
    Access control lists (ACL): filter access and traffic forwarding based on IP addresses and applications.
    Intrusion prevention systems (IPS): identify fast-spreading threats, such as zero-day or zero-hour attacks.
    Virtual private networks (VPN): secure access into an Org for remote workers.

    Access Methods
    Console:    
        a physical management port that provides out-of-band access(refers to access via a dedicated management channel). 
        The advantage is accessiblity even if no networking services are configured, such as performing the initial configuration. 
        A computer running terminal emulation software and a console cable are required.
    Secure Shell (SSH):	
        an in-band for remotely establishing a secure CLI connection, through a virtual interface. 
        Require active networking services and an active interface configured with an address on the device.
    Telnet:	
        an insecure, in-band method of remotely establishing a CLI session, through a virtual interface. 
        Unlike SSH, Telnet does not provide a secure, encrypted connection. User authentication, passwords, and commands are sent over the network in plaintext.

    Primary Command Modes
    User Exec Mode: Mode allows access to only a limited number of basic monitoring commands. It is often referred to as “view-only" mode.
        Switch> 
        Router>
    Privileged EXEC Mode: Mode allows access to all commands and features. The user can use any monitoring commands and execute configuration and management commands.
        Switch# 
        Router#
    Global configuration mode: identified by a prompt that ends with Switch(config)#.

    Configuration Mode and Subconfiguration Modes
    Line Configuration Mode: configure console, SSH, Telnet, or AUX access.
    Interface Configuration Mode: configure a SW port or R network interface.

    end = ctr+Z (From any subconfmode to privilageExec)
    enable X disable
    exit (From any mode to the previouse one)
    ? (Help)

    SW>(Prompt) show(command) (space) ip protocols(keywords/arguments)
    Keyword: a specific parameter defined in the operating system (in the figure, ip protocols).
    Argument: not predefined; it is a value or variable defined by the user (in the figure, 192.168.10.5).

    IOS Command Syntax Check
    boldface:	indicates commands and keywords that you enter literally as shown.
    italics:	indicates arguments for which you supply values.
    [x]:	    indicate an optional element (keyword or argument).
    {x}:	    indicate a required element (keyword or argument).
    [x {y | z }]:	indicate a required choice within an optional element. Spaces are used to clearly delineate parts of the command.
    EX: switchport port-security aging { static | time time | type {absolute | inactivity}}

    The table lists keystrokes to enhance command line editing.
    Tab:                        Completes a partial command name entry.
    Backspace:                  Erases the character to the left of the cursor.
    Ctrl+D:                     Erases the character at the cursor.
    Ctrl+U or Ctrl+X:           Erases all characters from the cursor back to the beginning of the command line.
    Ctrl+K:                     Erases all characters from the cursor to the end of the command line.
    Esc D:                      Erases all characters from the cursor to the end of the word.
    Ctrl+W:                     Erases the word to the left of the cursor.
    Ctrl+A:                     Moves the cursor to the beginning of the line.
    Ctrl+E:                     Moves the cursor to the end of command line.
    Left Arrow or Ctrl+B:       Moves the cursor one character to the left.
    Right Arrow or Ctrl+F:      Moves the cursor one character to the right.
    Esc F:                      Moves the cursor forward one word to the right.
    Esc B:                      Moves the cursor back one word to the left.
    Up Arrow or Ctrl+P:         Recalls the previous command in the history buffer, beginning with the most recent command.
    Down Arrow or Ctrl+N:       Goes to the next line in the the history buffer.
    Ctrl+R or Ctrl+I or Ctrl+L: Redisplays the system prompt and command line after a console message is received.

    This table lists commands used to exit out of an operation.
    Ctrl-C:	        ends any configuration mode and returns to privileged EXEC mode. When in setup mode, aborts back to the command prompt.
    Ctrl-Z:	        ends any configuration mode and returns to privileged EXEC mode.
    Ctrl-Shift-6:	All-purpose break sequence used to abort DNS lookups, traceroutes, pings, etc.

    Switch(config)# hostname Sw-Floor-1 (no hostname)
    Sw-Floor-1(config)# line console 0 -> Sw-Floor-1(config-line)# password cisco -> Sw-Floor-1(config-line)# login (secure user EXEC mode access) -> Sw-Floor-1(config-line)# logging synchronous (Prevents any alert message from cutting the command in hand)
    Sw-Floor-1(config)# enable secret class (secure privileged EXEC access)
    Sw-Floor-1(config)# line vty 0 15 -> Sw-Floor-1(config-line)# password cisco  -> Sw-Floor-1(config-line)# login (secure remote Telnet/ssh access) -> Sw-Floor-1(config-line)# exec-timeout 1 (if no activity for 1m will disconnect)
    Sw-Floor-1(config)# service password-encryption (encrypt all plaintext passwords)
    Sw-Floor-1(config)# banner motd #Authorized Access Only# (Banner Messages)
    Sw-Floor-1#show running-config | section ospf ((RAM). It reflects the current configuration)
    Sw-Floor-1#copy running-config startup-config (save changes made to the running configuration to the startup configuration file)
    Sw-Floor-1(config)#interface vlan 1 -> Sw-Floor-1(config-if)# description description-text -> Sw-Floor-1(config-if)# ip address 192.168.1.20 255.255.255.0  -> Sw-Floor-1(config-if)#IPv6 address ipv6/prefix -> Sw-Floor-1(config-if)# no shutdown 
    Sw-Floor-1(config)#ip default-gateway 192.168.1.1 (To access the SW remotely on the SVI)

    Sw-Floor-1# show ip/ipv6 interface brief
        Displays all Ethernet interfaces, their IP addresses, and their current status. The configured and connected has a Status of “up” and Protocol of “up” [L1&L2 IPv6 status]
        each interface has two IPv6, The second is the GUA that was configured. The first that begins with fe80 is the link-local unicast.
    Sw-Floor-1# show ip/ipv6 route
        Displays the contents of the IP routing tables stored in RAM.
    Sw-Floor-1# show interfaces
        Displays statistics for all interfaces on the device. However, this command will only display the IPv4 addressing information.
    Sw-Floor-1# show ip/ipv6 interface
        Displays the IPv4 statistics for all interfaces on a R.

    Sw-Floor-1#copy running-config (Take them copy and past them on another SW to apply DRY concept)[For SWs, it does not copy VLANs. For Rs, it does not copy interface status]


    Network Communications Protocols:	
        enable two or more devices to communicate over one or more networks. 
        The Ethernet family protocols such as IP, Transmission Control Protocol (TCP), HyperText Transfer Protocol (HTTP).
    Network Security Protocols:	
        secure data to provide authentication, data integrity, and data encryption. Include Secure Shell (SSH), Secure Sockets Layer (SSL), and Transport Layer Security (TLS).
    Routing Protocols:	
        enable Rs to exchange route information, compare path information, and then to select the best path. Include Open Shortest Path First (OSPF) and Border Gateway Protocol (BGP).
    Service Discovery Protocols: 
        Used for the automatic detection of devices or services. Include Dynamic Host Configuration Protocol (DHCP), and Domain Name System (DNS).

    Wi-Fi (IEEE 802.11): 
        (WLAN) technology, uses a contention-based protocol (CSMA/CA). 
        - The wireless NIC must first listen before transmitting to determine if the radio channel is clear. 
        - If another wireless device is transmitting, then the NIC must wait until the channel is clear. 
    Bluetooth (IEEE 802.15): 
        (WPAN) standard, uses a device pairing process to communicate over distances from 1 to 100 meters.
    WiMAX (IEEE 802.16): 
        Worldwide Interoperability for Microware Access (WiMAX), Uses a point-to-multipoint topology to provide wireless broadband access.
    Zigbee (IEEE 802.15.4): 
        Intended for applications that require short-range, low data-rates and long battery life. 
        Used for industrial and (IoT) environments such as wireless light SWs and medical device data collection.
    Wireless Access Point (AP): 
        Concentrate the wireless signals from users and connect to the existing copper-based network infrastructure, such as Ethernet. 
        Home and small business wireless Rs integrate the functions of a R, SW, and access point into one device.
    Wireless NIC adapters: 
        These provide wireless communication capability to network hosts.

    Decimal(0d) to Hexadecimal(0x) Conversions:
        - Convert the decimal number to 8-bit binary strings.                                (168 in binary(0b) is 10101000)
        - Divide the binary strings in groups of four starting from the rightmost position.  (10101000 in two groups of four binary digits is 1010 and 1000.)
        - Convert each four binary numbers into their equivalent hexadecimal digit.          (1010 is hex A and 1000 is hex 8)
    Hexadecimal to Decimal Conversion
        - Convert the hexadecimal number to 4-bit binary strings.                            (D2 in 4-bit binary strings is 1101 and 0010.)
        - Create 8-bit binary grouping starting from the rightmost position.                 (1101 and 0010 is 11010010 in an 8-bit grouping.)
        - Convert each 8-bit binary grouping into their equivalent decimal digit.            (11010010 in binary is equivalent to 210 in decimal)

    A multiaccess network: 
        is a network that can have two or more end devices attempting to access the network simultaneously. 
        [Ethernet LANs and WLANs] [Note: Ethernet LANs using SWs do not use a contention-based system because the SW and the host NIC operate in full-duplex mode]
        
        Contention-based access: 
            All nodes are operating in half-duplex, competing for the use of the medium. However, only one device can send at a time. 
            [Wireless, bus-topology, hub]
            
            Carrier sense multiple access with collision detection (CSMA/CD): 
                used on bus-topology 
                - both devices will detect the collision on the network, This is the (CD) portion of CSMA/CD. 
                - The NIC compares data transmitted with data received, or by recognizing that the signal amplitude is higher than normal on the media. 
                - The data sent by both devices will be corrupted and will need to be resent
            Carrier sense multiple access with collision avoidance (CSMA/CA): 
                used on WLANs 
                - Each device that transmits includes the "time duration" that it needs for the transmission. 
                - All other wireless devices receive this information and know how long the medium will be unavailable.
            Controlled access: 
                each node has its own time to use the medium. (Legacy Token Ring & Legacy ARCNET)




Network Topology:
    - Mesh:
        = Amount of cables needed can be calculated by: CN = (D * (D-1)) / 2 (where CN is Cables Needed, and D is the amount of devices on the network)




Network Communication Models:
    - Peer to Peer Networks
        = Windows Workgroup
    – Client/Server Networks
        = Mail Server
        = Web Server
        = File Server 
        = Print Server




- Network Devices:
    Client: A device that accesses a service made available by a server
    Server: A device that provides functions or services for clients
    Peer-to-Peer: Two PCs connected directly, whoever requests an info is the client and the other is the server
    SW: forward traffic between hosts within a LAN. You connect endhosts to, not to each other directly. Do not provide connectivity between remote LANs(over the internet)
    R: have fewer network interfaces. Provide connectivity between LANs and send data over the internet
    FireWall: 
        Software(host-based)&Hardware monitor and contorl network traffic based on configured rules. 
        Can be put inside network(Before R), outside(After R and before internet). Next-generation firewall has advanced filtering capabilities (ID, IP)




- Interfaces(ports) & Cables:
    RJ-45(Rgistered jack): used in an end of a copper ethernet cable
    Ethernet: collection of network protocols(Agreed upon communication system)/standards. 
    Speed: 
        Measured in bits per secod. Data on hardDrive is measured by Bytes. 
        Throughput: the measure of the transfer of bits across the media over a given period of time.
            The amount of traffic
                Bandwidth: is the capacity at which a medium can carry data. Measures the amount of data that can flow from one place to another in a given amount of time.
            The type of traffic
            The latency created by the number of network devices encountered between source and destination
                Latency: the amount of time, including delays, for data to travel from one given point to another.
        Goodput: 
            the measure of usable data transferred over a given period of time. 
            Equals throughput minus traffic overhead for establishing sessions, acknowledgments, encapsulation, and retransmitted bits.
            
        1KB: 1000 bits
        1MB: 1000,000 bits
        1GB: 1000,000,000 bits
        1TB: 1000,000,000,000 bits
    Ethernet Standards: Defined in IEEE. For copper-UTP (Base[Baseband signaling]-T[Twisted pair]):
        Connector-> RJ-45 Fast-Ethernet port to connect copper: Full-duplex, separate wires within the cable to transmit and receive data
        MIDI(TX 1&2):
            NIC on a PC ->          Pin 1&2 TX ~ Pin 3&6 RX.
            NIC on a FW ->          Pin 1&2 TX ~ Pin 3&6 RX.
            NIC on a R ->           Pin 1&2 TX ~ Pin 3&6 RX.
        MDIX(RX 1&2):
            Interface on a SW ->    Pin 3&6 TX ~ Pin 1&2 RX.
            Interface on a Hub->    Pin 3&6 TX ~ Pin 1&2 RX.

        Copper: electrical signal interpreted by endhosts as 0 or a 1. Byte(8 bits)/Bit(0s or 1s).
            Co-axial cable: Half-duplex, with TV dish receiver, BNC connector
                think: 10 base 2
                    BandWidth=10Mb, baseband(singal Was Not Loaded On Carrier) x Broadband(singal Was Loaded On Carrier)
                    2(Max. Length is 185 M)
                thick: 10 base 5
                    5(Max. Length is 500 M.)
            Twisted Pair: RJ-45 connector
                Types:
                    UTP: Cat 3,4,5,5e,6,6a
                        Unshield Twisted Paird. Has no metalic sheild which make them vulnerable for EMI & RFI. 
                        Emitts a faint signal outside of the cable, which can be copied. Security Risk.
                    STP: Cat 5e,6,6a,7, 8(25G&40G)
                        Shield Twisted Paird, prevents from external EMI & RFI.
                Protections:
                    Shielding:
                        Electromagnetic interference (EMI) or radio frequency interference (RFI):  
                            EMI and RFI signals can distort and corrupt the data signals being carried. 
                            Potential sources include radio waves and electromagnetic devices, such as fluorescent lights or electric motors.
                    Wire twisting:    
                        Crosstalk:
                            A disturbance caused by the electric or magnetic fields of a signal on one wire to the signal in an adjacent wire.
                            Twisting generates two magnetic fields opposite to each others protects against electromagnatic interference(EMI). 4 twists means 8 wires in total.
                            In telephone circuits, crosstalk can result in hearing part of another voice conversation from an adjacent circuit. 
                            Specifically, when an electrical current flows through a wire, it creates a small, circular magnetic field around the wire, which can be picked up by an adjacent wire.
                Connection types:
                    Straight-Through cable: From PC/R/FW to SW/HuB, connects pin 1&1, 2&2, 3&3, 6&6.
                    Crossover cable: PC-to-PC or PC-to-router or SW-to-SW etc., pairs are reversed at each end. Pins LTR 1&3, 2&6, 3&1, 6&2.
                    rollover cable(console): connect a workstation to a R or SW console port. Pin 1to8, 2to7, 3to6, 4to5, 5to4, 6to3, 7to2, 8to1.
                    Auto-MDIX(medium-dependent interface crossover): 
                        Allow devices' NIC to automatically detect where their neighbour are transmitting data on and adjust the place they use to transmit and receive data to exchange normally
                Cables Specifications:
                    [10Base-T & 100Base-T only 4 wires used]
                    [1000Base-T & 10GBase-T all 8 wires used - each pair is Bi-Directional]
                    Standards:
                        10Base-T   (Ethernet[Cat 3&4]) ->                       10 Mbps - [2 pairs (4 wires)] - 100M
                        100Base-T  (Fast Ethernet[Cat 5])   ->                 100 Mbps - [2 pairs (4 wires)] - 100M
                        1000Base-T (Gigabit Ethernet[Cat 5e]) ->                 1 Gbps - [4 pairs (8 wires)] - 100M
                        10GBase-T  (10 Gigabit Ethernet[Cat 6, Cat 6a, 7]) ->   10 Gbps - [4 pairs (8 wires)] - 100M
                        40GBase-T  (40 Gigabit Ethernet[Cat 8]) ->              40 Gbps - [4 pairs (8 wires)] - 100M

        Fiber-optic(Light over glass fiber): separate cables to transmit and receive data
            SW has 4 interfaces for SFP(Small Form-factor pluggable)[Connects to Fiber-Optic] Transceiver
            R  has 4 interfaces for RJ-45 and rest are for SFP.
            Two connectors at each end, one to RX and one to TX at each end. 
            A yellow jacket is for single-mode fiber cables and orange (or aqua) for multimode fiber cables.
            Connectors:
                Straight-Tip (ST): 
                    ST connectors were one of the first connector types used. The connector locks securely with a 'twist-on/twist-off' bayonet-style mechanism.
                Subscriber Connector (SC): 
                    'square connectors'. Widely-adopted LAN and WAN connector that uses a push-pull mechanism to ensure positive insertion. 
                    This connector type is used with multimode and single-mode fiber.
                Lucent Connector (LC) Simplex: 
                    Smaller version of the SC. Called little or local connectors and are quickly growing in popularity due to their smaller size.
                Duplex Multimode LC: 
                    A duplex multimode LC connector is similar to an LC simplex connector, but uses a duplex connector.
            Stracture of the cable:
                1- Fiberglass core, light is transmitted down this core
                2- cladding, reflects light
                3- a protective buffer, protects fiber glass from breaking
                4- The outer jacket of the cable
            Mode:
                Single-mode(SM): 
                    Core diameter is narrower than multi-mode, allow single angle from a laser-based transmitter to enter the core, allow longer cables than UTP&MM, 
                    more expensive than multi-mode (due to Laser-based SFP transmitter) 
                Multi-mode(MM):  
                    Core diameter is wider than Single-mode, allow multiple-angles of light waves to enter the core, allow longer cables than UTP but shorter than SM, 
                    cheaber than single-mode (due to LEDs-based SFP transmitter)
            Standards:
                1000Base-LX  (MM or SM) ->   1  Gbps - 550M(MM), 5KM(SM)
                10GBase-SR   (MM) ->         10 Gbps - 400M
                10GBase-LR   (SM) ->         10 Gbps - 10KM
                10GBase-ER   (SM) ->         10 Gbps - 30KM

        Serial:
            Has two sides, DCE and DTE. At the DCE side, a clock-rate is needed to be configured.




- Network Model: 
    Categorize and provide a structure for networking protocols(Set of logical rules defining how network devices and software should work) and standards

    OSI(Open system interconnection)[Suite of protocols]:
     A conceptual model that categorizes and standarizes the different functions in a network, created by ISO, Functions are divided into 7 layers
        - Application developers focuses on below 3 layers, CPU processes below 5:
            7- Application: 
                - Closest to the end-user, and interacts with software apps,  
                - Identifying communication partners & Synchronizing communications, and Process control
                - Workgroup(Peer-to-Peer) | Client/Server(Domain Controller)
                - Protocols:
                    - Web:
                        HTTP(Hyper text transfer protocol http://)-> 80/TCP, clear text [ManInTheMiddle attack]
                        HTTPs(Secured)-> 443/TCP, encrypted
                        Functionality:
                            PC->     sends Http(s) request
                            Server-> replies Http response, return code[200/404]
                        REST: Representational State Transfer. A web service that uses application programming interfaces (APIs) and HTTP requests to create web applications.
                    - IP Configuration:
                        Manual IP: Configured through GUI/CLI, not recommended for the raise of human error
                        DHCP(dynamic host configuration protocol)-> 67,68/UDP. OS server, creating boul of IPs. 
                            DORA: Discover, Offer, Request, Acknowledge
                                - A new PC enters, sends "DHCP Discover BC" in the network requesting an IP, 
                                - Then DHCP server replies "DHCP Offer BC", 
                                - Then PC replies confirming to take the IP "DHCP Request BC", 
                                - Finally DHCP server confirms a lease "DHCP Acknowledge BC" 
                                Lease: Rental IP, 
                                    After 50% of lease expiry the PC goes to the server to renew the lease unicasting. 
                                    If 87% passed and server never replied back, it will start requesting from another server. 
                            Alternate: 
                             If DHCP not available, endhost takes its IP from:
                                APIPA(Automatic Private IP address): 
                                    If DHCP not available, and I did not configure an alternative, APIPA will assign the device 169.254.x.x/16 but only LAN and non-routable. 
                                    And the endhost still send each 3Min a BC to request IP from DHCP hoping it will respond
                    - Emails:
                        SMTP(Simple mail transfer protocol)[send an email to a mail server & enables the servers to send the email to other servers]-> 25/TCP
                            Exchange, lotus domino, postfix
                        POP3(s)(Post Office Protocol)[Enables clients to retrieve email from a mail server and download it]-> 110/TCP
                        IMAP(s)(Internet Message Access Protocol)[Stores emails on a mail server and enables view and manipulation as though they were stored locally]-> 143/TCP
                        Active synch[Pushes notifications]
                    - Files:
                        FTP(File transfer protocol ftp://)[Download/Upload]-> 20(data)&21(service Control, Dw/Up)
                        SFTP: SSH File Transfer Protocol. As an extension to Secure Shell (SSH) protocol, the file transfer is encrypted.
                        TFTP: Trivial File Transfer Protocol. A simple, connectionless file transfer protocol with best-effort, unacknowledged file delivery. It uses less overhead than FTP.
                        SMB(Default in Win., authenticates on user level)/NFS(Linux, authenticates on PC level): File sharing
                        P2P(Peer-to-Peer): Creating torrent server, 
                            - When uploading, it fragment the whole file into thousand pieces
                            - When downloading, it sees if another PC connecting to same server and already downloading, 
                                he connects to server and those PCs to download from whoever holds any portion of the file  
                    - Remote Logins:
                        Telnet-> 23/TCP, clear text
                        SSH(secured shell)-> 22/TCP, encrypted
                        RDP(remote desktop protocol)-> 3389/TCP
                    - DNS(Domain Name System) and alias: 
                        Relationship between site names and their IPs. 53/TCP between DNS-and-DNS & 53/UDP between Host-and-DNS. 
                        You can put a prefered DNS and an alternative, with unlimited DNSs in PCs.
                        Queries:
                            Recursive query: Asking your prefered DNS about an info, if replied with the info, we call it an (authoritative server)
                            Iterative query: in case your prefered DNS has no clue, it forwards you to the root hint as itertative query and we call it a (non-authoritative server)
                                root hint(.): 13 super computer around the world, either to help you with the IP or gets a referal DNS


            6- Presentation: 
                - Compression/Decompression, Encoding/Decoding(ASCII<->ML), Defines data format(jpg, exe, txt...)[What defines the information format are the file header&Trailer]
                - Translation between application & Network format to be sent over the network.
                - Translation between Different application layers format to ensure receiving host can understand, i.e. Encryption & Decryption of Data.


            5- Session: 
                - Defines communication mode(Single, H-Duplex, F-Duplex)
                - Controls dialogues(Logical Sessions) between communication hosts:
                    - Establishes[Src. negotiates for a logical session],
                    - Manages, 
                    - Terminates[Src.-> the local application(Your browser) & Dst.-> The remote application(Youtube)]
                        [on server-> This PC>Manage>Shared>sessions | on client-> This PC>Manage>Tools>Com.Management]


        - Network Engineers focuses on below 4 layers, Data received from top 3 Layers to be processed in below 4, Encapsulation starts at L4 and ends at L2:
            4- Transport(Dst.&Src. Processes number[ports], manages the data transport between the processes running on each host): 
                - Provides transparent transfer of data between end hosts & Process-to-Process for applications
                - Provide services: Error recovery, reliable data transfer, data sequencing, and flow control
                - Provide L4 addressing(Port numbers): 
                    Identifying the application layer protocol:
                        Socket pair(Src.&Dst. IP&Port): uniques and identifies the two hosts. ie. 70.20.112.21:80
                         PC:  (TCP):Src: 500000 Dst: 80
                         SRV: (TCP):Src: 80 Dst: 500000
                            Src.Port: Randomly selectede by PC, helps identify the session.
                            Dst.Port: Identifies the application layer protocol, ie. TCP 80 = HTTP
                    Providing session(An exchange of data between two or more communication devices) multiplexing:
                        Multiplexing of upper layer application using port number, 
                            (Adding an identifier to the target app)[Src.Port & Dst.Port]
                - L4 Encapsulation: Adds a header L4 PDU to [data] or [each segment](if broken into pieces) along with its sequence number
                - Segmentation and Segment-reassemble of data for commumnications between Endhosts

                - Ports: 
                    - Services on a PC exits from a "random" port number
                    - Reachs a "specific" port on server to request a specific service. NOTE: Unused ports get closed for vulnerability protection.
                    Port management:
                        - Port Num. (2**16): C:>Windows>System32>drivers>etc>services
                            Well-known/System-> 0    ~ 1023                     [used by system (or root) processes or by programs executed by privileged users]
                            User-Defined------> 1024 ~ 65535 
                                - Registered------> (Src.Port) 1024  ~ 49151    [used by ordinary user processes, or programs executed by ordinary users]
                                - Dynamic/Private-> (Dst.Port) 49152 ~ 65535    [used by PC when selecting the random Src port]
                - Port Numbers:
                    TCP                    UDP                    TCP&UDP
                    FTP Data (20)          DHCP server (67)       DNS (53)
                    FTP control (21)       DHCP server (68)
                    SSH (22)               TFTP (69)
                    Telent (23)            SNMP Agent (161)
                    SMTP (25)              SNMP Manager (162)
                    HTTP (80)              Syslog (514)
                    POP3 (110)
                    HTTPS (443)
                - TCP(Transmission control protocol, tracks and manages the flow of packets): 
                    Connection-oriented: 
                        Before sending data to Dst., the two hosts communicate to establish a connection. Once established, the data exchange begins.
                    Reliable communication: 
                        Dst.Host must acknowledge that it received each TCP segment
                        If a segment isn't acknowledged, it is sent again
                            Three-way Handshake:
                                Src. Sends SYN, Dst. Replies SYN&ACK, Src. Replies Ack
                            Four-way Hanshake:
                                Src. Sends FIN, Dst. Replies ACK, Dst. Sends FIN, Src. Replies Ack
                    Sequencing:
                     Seuqence numbers allow Dst.Hosts to put segments in the correct order even if they arrive out of order
                        Three-way Handshake:
                            Src.SYN with Seq:10. Dst.SYN&ACK with Seq:50 and ACK:11, Src.ACK with Seq:11 and Ack:51
                        Data Exchange:
                            Dst. Seq:51 and ACK:12, Src. Seq:12 and ACK:52
                        Retransmission:
                            Src. Seq:20, Dst. Ack:21, Src. Seq:21(with error), Src. Seq:21, Dst. Ack:22
                            NOTE: Src. waits a certain amount of time for an ack, if not received, it retransmits the last sequence
                        NOTE: 
                            Each Src.&Dst. selects their initial Seq number, and the communication onforward is an ACK replies to the Seq messages. Each Seq and ack increases during the exchange
                            Hosts set a rand initial Seq number
                            Forward Acknowledgment is used to indicate the Seq number of the next segment the host expects to receive
                    Flow control:
                     Acknowledging every single segment, no matter what size, is inefficient. Therefore, Window Size field allows more data to be sent before an acknowledgement is required.
                     Dst.Host can tell the Src.Host to increase/decrease the rate that data is sent.
                        A 'sliding window' can be used to dynamically adjust how large the window size is:
                            Increased as much as possible, till a segment is dropped, then the window sizing is back to down to a more reasonble level and slowly increases again 
                        Three-way Handshake data exchange:
                            Src. Sending SYNs, Dst. Replying Ack[Checks its buffer and when it is full, it sends an Ack to the Src., then pushes data to above layers]
                    Usage" 
                        Youtube normal videos, web browser, E-mail, and file transfer
                    TCP header-> Src.Port(16b)+Dst.Port(16b)+Sequence number(32b)+SeqAck number(32b)+Data offset(4b)+Reserved(6b)[Flags]+Window Size(16b)+Checksum(16b)+Urgent Pointer(16b)+Options&Padding
                        Sequencing: 
                         When Src.&Dst. agree on a buffer at the Dst. to receive data on
                            ie., Src. Sends Seq100,Seq200(has error),Seq300,Seq400. If Seq200 delivered with an error, the Dst. replise Ack200, means sends me from Seq200 up till 4(Dst. agreed buffer limit)
                            ie., Src. Sends Seq100,Seq200,Seq300,Seq400. If all delivered with an error-free, however, the Dst. replise Ack200(had error). So, Src. will resend the 4 Sequences again to Dst. as a precaution 
                            Three-Way Handshake(Creating the logical session, and agreeing on the Dst. buffer): 
                                Starting: Src. sends a SYN= ie.100, Dst. Replies an ACK= ie.101 AND a SYN= ie.200 same time, Src. Replies ACK= ie. 201. So, data will be sent starting from 202 to the Dst.buffer
                            Four-Way Handshake(Terminating the logical session): 
                                Ending:   Src. sends a FIN, Dst. Replies an ACK, Dst. sends a FIN, Src. Replies an ACK
                        Offset: 
                            Number of 32b words in TCP header, Min. value of 5 multiply it by 4 to get byte count
                        Flags: Reduced,ECN echo,URG,ACK,PSH,RST,SYN,FIN
                            URG(urgent)0x20: QoS
                            Ack(Acknowledge)0x10: Type of package, not the value
                            PSH(Push)0x08: Src. Puts psh on an increment of the buffer of the Dst., ie. every 4th segment the Src. will mark it with psh to know this is last to send and wait for ACK
                            RST(Reset)0x04: Src. sends to Dst. to reset all the buffer if there is mutliple errors in segments received, and start sending over
                            Syn(Synchronizing)0x02:
                            FIN(Finalize)0x01: 
                        Error correction [TCP retransmission], 
                        Flow control:
                            [Windowing[Window size], buffering, congestion avoidance]. Service the purpose of communication with reliability
                        Checksum: 
                            Of entire TCP segment and pseudo header(Part of IP header)
                        Options: 
                            0 End of options, 1 No Operation(NOP,Pad), 2 Max.Segment size, 3 Window Scale, 4 Selective ACK ok, 8 Timestamp
                            If data offset > 5. Padded at the end with "0" bytes if necessary
                - UDP(User datagram protocol):
                    Not a connection-oriented:
                        Src.Host does not establish a connection with the Dst.Host before sending data. The data is simply sent.
                    Does not provide reliable communication:
                        Acknowledgments are not sent for received segments. If a segment is lost, UDP has no mechanism to re-transmit it. Segments are sent 'best-effort'(Makes the effort, but no guarantee)
                    Does not provide Sequencing:
                        No sequence number field in the UDP header. If segments arrive out of order, UDP has no mechanism to put them back in order.
                    Does not provide flow control:
                        UDP has no mechanism like TCP's window size to control the flow of data
                    Usage:
                        Youtube live videos and VoIP
                    UDP header-> Src.Port(16b) + Dst.Port(16b) + length(16b) + Checksum(16b) + Data


            3- Network(Dst.&Src. Logical network addresses): 
                Addressing end devices: 
                 Logical addressing configuration for end devices (S.&Dst. CLNS/IP), unique to identify them on the network.
                    IPv4: 
                        decimal dottet notation, 32b = 4Byte = 4[groups]*8[bits], (0~1)*8.(0~1)*8.(0~1)*8.(0~1)*8 [in binary], and (0~255).(0~255).(0~255).(0~255) [in decimal]
                        Network Portion(The netmask num /x) i.e. /8, 
                        Host Portion((netmask num - 32)) i.e. 8-32=24 
                    IPv6: 
                        HEX Groups seprated by colon, 8[groups]*4[HEX]=32 HEXs, each HEX has 4b, 4[HEX]*4[bits]=16b[Hextet] in each group, 
                        2[0~1]**128b(16b*8grps) possibilities (340 undecillion, 36 zeros
                    Viewing:
                        GUI in network configurations
                        CLI "ipconfig"/"ifconfig"
                    Configuring: 
                        Static(Manually)
                        Dynamic (DHCP) [NOTE: DHCP related attacks, like DHCP starvation attack] 
                Internet Protocol
                    IPv4(32-bit): 
                        Internet Protocol version 4. 
                        Receives message segments from the transport layer, packages messages into packets, and addresses packets for end-to-end delivery over a network.
                        NAT: Network Address Translation. Translates IPv4 addresses from a private network into globally unique public IPv4 addresses.
                    IPv6(128-bit): 
                        IP version 6. Similar to IPv4.
                    Messaging: Internet Control Message Protocols
                     IP is only a best-effort protocol, the TCP/IP suite does provide for error messages and informational messages when communicating with another IP device. 
                     These messages are sent using the services of ICMP.
                        Type of messages:
                            Host reachability: 
                                - The Lhost sends an ICMP Echo Request to another host [Done using "ping" utility] 
                                - If the Dst.host is available, it responds with an Echo Reply.
                            Destination/Service Unreachable: 
                             When a host or DGway receives a packet that it cannot deliver, 
                             it can use an "ICMP Destination Unreachable" message to notify the Src. that the Dst. or service is unreachable. 
                             The message will include a code that indicates "why" the packet could not be delivered.
                                Codes for ICMPv4:
                                    0 - net unreachable
                                    1 - Host unreachable
                                    2 - Protocol unreachable
                                    3 - Port unreachable
                                Codes for ICMPv6:
                                    0 - No route to destination
                                    1 - Communication with the destination is administratively prohibited (e.g., firewall)
                                    2 – Beyond scope of the source address
                                    3 - Address unreachable
                                    4 - Port unreachable
                            Time exceeded: 
                                used by a R to indicate that a packet cannot be forwarded because the TTL[IPv4] or Hop Limit[IPv6] field of the packet was decremented to 0.
                                Note: Time Exceeded messages are used by the traceroute tool.
                        Versions:
                            ICMPv4: 
                                ICMP for IPv4. Provides feedback to a Src.host about errors in packet delivery.
                            ICMPv6: 
                                ICMP for IPv6. Similar functionality to ICMPv4 but is uses for IPv6 packets.
                                New features:
                                    Messaging between an IPv6 R and an IPv6 device, including dynamic address allocation:                                        
                                        R Solicitation (RS):
                                            - Host with IPV6-enabled sends a (RS) requesting that R generate a (RAs) immediately rather than at their next scheduled time.
                                            Message:
                                                PC1:"Hi, I just booted up, Is there an IPv6 R on the network? I need to know how to get my IPv6 info dynamically"
                                                R1: "Hi all IPv6-enabled devices. 
                                                    I'm R1 and you can use SLAAC to create an IPv6 Global Unique Address(GUA). 
                                                    The prefix is 2001:db8:acad:1::/64. BTW, use my Link_local Address(LLA) fe80::1 as your DGway"
                                        R Advertisement (RA):
                                            - Rs with IPv6-enabled, provides addressing info across the network every 200Sec (prefix, prefix length, DNS address, and domain name) 
                                            - A host using Stateless Address Autoconfiguration(SLAAC) will set its DGway to the Link-Local Address(LLA) of the R that sent the "RA".
                                            Message:
                                                "Hi all IPv6-enabled devices. 
                                                I'm R1 and you can use SLAAC to create an IPv6 Global Unique Address(GUA). 
                                                The prefix is 2001:db8:acad:1::/64. BTW, use my Link_local Address(LLA) fe80::1 as your DGway"
                                    Messaging between an IPv6 devices, including duplicate address detection and address resolution:
                                        Neighbor Solicitation (NS):
                                            - To [determine the MAC] of a neighbor(ARP), or to [verify that a neighbor reachability] via a cached MAC, or for [Duplicate Address Detection(DAD)].
                                            - IPv6 ARP process:
                                                - A device with IPv6-enabled sends a (NS) to the solicited node address with the known (destination/targeted) IPv6. 
                                                - The solicited node that has the targeted IPv6 will respond with a (NA) containing its MAC.
                                            - IPv6 DAD process:
                                                - A node sends a (NS) with its own new IPv6 as the destination/targeted IPv6.
                                                - If another device has same address, they respond with a (NA). 
                                                - If no (NA) is recieved within a certain amount of time, the new acquired unicast address is unique and acceptable for use.
                                                Message:
                                                    "Will whoever has the IPv6 address 2001:db8:1::10, send me your MAC address?"
                                        Neighbor Advertisement (NA):
                                            - Sent in response to a (NS), or sent as an unsolicited (NA) to announce a MAC change.
                                            Message:
                                                PC2:"Will whoever has the IPv6 address 2001:db8:1::10, send me your MAC address?"
                                                PC1:"I'm 2001:db8:1::10 and my MAC is 00:aa:bb:cc:dd:ee"
                                    Redirect:
                                        - Used by Rs with IPv6-enabled to inform hosts of a better first-hop for a destination.
                Routing: 
                 Provides services to direct the packets to a remote Dst.host. 
                    - R selects the best path and direct packets toward the Dst.host with routing process. 
                    - IP addressing information remains the same from Src.host until it arrives at the Dst.host, except when (NAT) in place for IPv4.
                    Protocols
                        OSPF: 
                            Open Shortest Path First. 
                            Uses a hierarchical design based on areas. An open standard interior routing protocol.
                        EIGRP: 
                            Enhanced Interior Gateway Routing Protocol. 
                            Uses a composite metric based on bandwidth, delay, load and reliability. An open standard routing protocol developed by Cisco.
                        BGP: 
                            Border Gateway Protocol. 
                            Used between Internet Service Providers (ISPs). An open standard exterior gateway routing protocol. 
                            Also commonly used between ISPs and their large private clients to exchange routing information.
                L3 De/Encapsulation: 
                    Encapsulation: 
                        Adds a header L3 PDU to segments and becomes a Packet. Adds IP header information, such as Src.&Dst.IP.
                    De-encapsulation: 
                     At the network layer of the Dst.host, checks the IP header of the packet. 
                        - If the Dst.IP matches its own IP, the IP header is removed from the packet. 
                        - Then the resulting Layer 4 PDU is passed up to the appropriate service at the transport layer.
                Considerations:
                    MTU: 
                        Maximum Transmission Unit
                        Part of the control communication between the data-link and network layer is the establishment of a Max. size of PDU that each medium can transport.
                    Fragmentation: 
                        In some cases, a R, must split up a packet when forwarding it from one medium to another with a smaller MTU. 
                        Fragmentation causes latency. IPv6 packets cannot be fragmented by the R.


        - NIC processes below 2:
            2- Data-Link(Dst.&Src. Physical addresses, NIC-to-NIC communications within the same network, preparing packets for transmission medium): 
                Adds a header&trailer L2 PDU to Packet and becomes a frame, 
                Uses layer2 addressing(S.&Dst.MAC[media access control]/CAM[content addressable memory]/BIA[burned in address on ROM]), 
                LLC(Logical link control), negotiate with upper layer to understand what type of addressing (v4/v6) and format for transmission over a physical medium
                Provides node-to-node connectivity and data transfer(PC to SW OR SW to SW OR R to R etc.), SWes operates at L2
                convert data to binary or original form to be sent over the network, 
                Detects and possibly corrects L1 errors,

                IEEE 802 LAN/MAN Data-Link Sublayers:
                    Logical Link Control (LLC): 
                        handle communication between the 'Upper layers'[Software] and the 'Lower Layers'[Hardware] of the protocol stack. 
                        takes the network protocol data (IPv4 or IPv6 packet), and adds Layer 2 'Control information' to help deliver the packet to the destination node. 
                        It places info in the frame that identifies which network layer protocol is being used for the frame, which allows multiple Layer 3 protocols, such as IPv4 and IPv6, to use the same NIC and media.
                    Media Access Control (MAC): 
                        controls the NIC and other hardware that is responsible for sending and receiving data on the wired or wireless LAN/MAN medium. This in hardware. 
                        Data encapsulation and media access control. It provides MAC addressing and it is integrated with various physical layer technologies (Ethernet, WLAN, WPAN).
                        Frame delimiting: Provides important delimiters to identify fields within a frame. These delimiting bits provide synchronization between the transmitting and receiving nodes.
                        Addressing: Provides source and destination addressing for transporting the Layer 2 frame between devices on the same shared medium.
                        Error detection: Includes a trailer used to detect transmission errors.
                        Allowing multiple devices to communicate over a shared (half-duplex) medium. Full-duplex communications do not require access control.
                        Sees the logical topology of a network. Which influences the type of network framing and media access control used.

                Layer 2 function that a R perform:
                    Accepts a frame from a medium in a LAN
                    De-encapsulates the frames
                    Re-encapsulates the packet into a new frame
                    Forwards the new frame appropriate to the medium of that segment of the physical network

                Protocols:
                    ARP(ICMPv6 ND[NeighbourDiscovery] for IPv6): Address Resolution Protocol. 
                        ARP: 
                            Provides dynamic address mapping between an IPv4 address and a hardware address (MAC).
                            Note: You may see other documentation state that ARP operates at the Internet Layer (OSI Layer 3). Do not use IPv4, but sends Ethernet broadcast.
                            However, in this course we state that ARP operates at the Network-Access layer TCP/IP (OSI Layer 2) because it's primary purpose is the discover the MAC address of the destination.
                            Dst.IPv4 addresses are either known or resolved by device name. However, MAC must be discovered.
                            It resolves IPv4 addresses to MAC addresses & Maintains a table of IPv4 to MAC address mappings
                            Functionality:
                                When a packet is sent to data-link to be encapsulated into a frame, it compares the Dst.IPv4 to Src.IPv4 to determine if located on the same Layer 3 network, then it refers to a table to find the MAC of the Dst.IPv4 address(LocalHost/DGway for RemoteHost). 
                                This table is stored temporarily in RAM memory and called the (ARP table) or the (ARP cache).
                                - If the device locates the IPv4, its corresponding MAC is pulled to be used in the frame. 
                                    - If the packet’s Dst.IPv4 is on the same network as the Src.IPv4, the Src.Device will search the ARP table for the Dst.IPv4 of the destination.
                                    - If the Dst.IPv4 is on a different network than the Src.IPv4, the Src.Device will search the ARP table for the IPv4 of the DGway.
                                - If there is no entry found, then the device sends an ARP request.
                                    ARP Request: BC
                                        There is no IPv4 header. The ARP request is encapsulated directly in an Ethernet frame using the following header information:
                                        Dst.MAC: BC FF-FF-FF-FF-FF-FF requiring all NICs on the LAN to accept and process the ARP request. And Rs will not forward BC.
                                        Src.MAC:  MAC of the sender of the ARP request.
                                        Type:     Type field of 0x806. This informs the receiving NIC that the data portion of the frame needs to be passed to the ARP process.
                                    ARP Reply: Unicast
                                        Only one device on the LAN will have an IPv4 that matches the target IPv4 in the ARP request. All other devices will not reply. Encapsulated using the following header information:
                                        Dst.MAC: MAC of the sender of the ARP request.
                                        Src.MAC:  MAC of the sender of the ARP reply.
                                        Type:     Type field of 0x806.
                                - If no device responds to the ARP request, the packet is dropped because a frame cannot be created.
                                    Issues:
                                        BC:       ARP req. is received and processed by every device on the LAN. If a large number of devices all start accessing network services at the same time, there could be some reduction in performance for a short period of time. After the devices send out the initial ARP broadcasts and have learned the necessary MAC addresses, any impact on the network will be minimized.
                                        Spoofing/poisoning: The threat actor sends an ARP reply with its own MAC address. The receiver sends these packets to the threat actor. Enterprise level SWs include mitigation techniques known as dynamic ARP inspection (DAI).
                        IPV6 ND(IETF RFC 4861):
                            Same as ARP but:
                                - Table is called "Neighbor Cache table".
                                - Request: Type of 128
                                    Dst.MAC is multicast[Makes it easy to determine if the packet is for him, without having to send it to the OS to process it] + Src.MAC is sender + Src.IPv6 is sender + Dst.IPv6 is SN multicast + (ICMPv6 NS[NeighborSolicitation]) -> Target IPv6 is Dst.IPv6
                                - Reply:
                                    Dst.MAC is req.Sender + Src.MAC is req.Receiver + Src.IPv6 is req.Receiver + Dst.IPv6 is req.Sender + (ICMPv6 NA[NeighborAdvertisement)-> Target IPv6 is req.Receiver + Target MAC is req.Receiver
                            ND provides address resolution, R discovery, and redirection services for IPv6 using ICMPv6. ICMPv6 ND uses five ICMPv6 messages to perform these services:
                                - Neighbor Solicitation messages  [device-to-device messaging like ARP]
                                - Neighbor Advertisement messages [device-to-device messaging like ARP]
                                - R Solicitation messages    [devices-to-routers messaging for DHCPv6 and SLAAC]
                                - R Advertisement messages   [devices-to-routers messaging for DHCPv6 and SLAAC]
                                - Redirect Message                [better next-hop selection]
                    Ethernet
                    802.11 Wireless
                    Point-to-Point Protocol (PPP)
                    High-Level Data Link Control (HDLC)
                    Frame Relay


            1- Physical(Timing and synchronization bits-> Physical Components, Encoding[represent digital info. by converting a stream of data bits into a predefined "code”], Signaling[type of signal represents a "1" and a "0", For example, a long pulse might represent a 1 whereas a short pulse might represent a 0]): 
                Modulation: physical layer term describes the process by which one wave modifies another wave.
                Ports name for packet in/out of devices gets carried in L1
                Defines physical characteristics(Voltage, Max transmission distance, physical connectors, cable specifications) of the medium used to tranfer data between devices, 
                Digital bits are converted into electrical(For wired connections) or radio(For wireless connections) 

                Data Link Protocols
                Ethernet: Defines the rules for wiring and signaling standards of the network access layer.
                WLAN: Wireless Local Area Network. Defines the rules for wireless signaling across the 2.4 GHz and 5 GHz radio frequencies.


        - Encapsulation:
            Operations:
                Adjacent-Layer interaction: All layers interaction, Encapsulation & De-Encapsulation
                Same-Layer interaction: Interaction between two same-layers (Application & Application)
                PDUs: Protocol data units(Segment, Packet, Frame.). At L1 PDU = Bit.
            Layers:
                Transport-> Segment (TCP/UDP header + data)
                Network-> Packet (IP header+ TCP/UDP header + data)
                DLL-> Frame ([Eth.header+ IP header+ TCP/UDP header + data](Payload) + Eth.Trailer)
        - Devices:
            Network: R [De-encapsulate 3 Layers]
            DLL: SW, Bridge [De-encapsulate 2 Layers]
            Physical: Hub, Repeater

    TCP/IP:
     A conceptual model and set of communications protocols used in the internet and other networks, Developed by DARPA
        4- Application          = OSI(App, Pres, Sess)     = TCP/IP(HTTP/HTTPs/REST, SMTP/POP3/IMAP, DNS, DHCPv4/v6/SLAAC, FTP/TFTP/SFTP) & ISO(ACSE,ROSE, TRSE, SESE) & AppleTalk(AFP) & NovelNetwork(NDS)
        3- Transport            = OSI(Transport)           = TCP/IP(TCP, UDP) & ISO(TP0,TP1,TP2,TP3,TP4) & AppleTalk(AFP,AEP,NBP,RTMP) & NovelNetwork(SPX)
        2- Internet             = OSI(Network)             = TCP/IP(IPv4/v6/NAT, ICMPv4/v6/v6 ND, OSPF/EIGRP/BGP) & ISO(CONP/CMNS,CLNP/CLNS) & AppleTalk(AARP) & NovelNetwork(IPX)
        1- Network Access/Link  = OSI(Data-Link, Physical) = TCP/IP&ISO&AppleTalk&NovelNetwork (Ethernet,ARP,WLAN)




- CLI: USB Mini-B OR RJ45
    Connecting CISCO device to console Rollover[Pin 1to8, 2to7, 3to6, 4to5, 5to4, 6to3, 7to2, 8to1](One end is DP9[Serial port, nowdays works with adapter for USB port] and other is RJ45) cable to configure and terminal emulator 
    - Modes:
        User EXEC Mode: Indicated with ">" sign after the hostname "R1>". Can loo at some things, but cannot do configurations.
        Privilage EXEC Mode: Entered with "enable" command. Indicated with "#" sign. Complete access to view the devices' configuration, restart the device, etc. Can only change time on device and save current configuration file.
        Global Configuration Mode: Entered with "configure terminal" command. Indicated with "(conf)#" sign.
    - Configuration Files: "show running-config" from Privilage
    Two separate configuration files kept on the device at once. To copy from running to startup, "write" OR "write memory" OR "copy running-config startup-config" from privilage Mode
        Running-config: The current active configuration, any entered commands within the session is editing the active configuration.
        Startup-config: The configuration that will be loaded upon restart of the device
    PrivilegedEXEC passwords: 
        "enable password YourPassword" for Privilage Mode & "service passwork-encryption", uses type 7 encryption(CISCO Algorithm). 
        "enable secret YourPassword", creates and uses type 5 encryption(MD5) and "enable password" is ignored
        IF:
            enabled "serice passwork-encryption" Current and future passwords will be encrypted. 
            disabled "serice passwork-encryption" Current will not be decrypted and future passwords will not be encrypted. 
    Deleting Configurations: "no TheCommand"




- Ethernet LAN switching: L1 & L2
     Defning a LAN: Contained within a limitely small area, adding more SW to each other expand LANs do not separate them, however connecting different SWs to same R considers separate LANs
     Frame(Min. Size is 64Bytes & Max. 1518Bytes)[excluding preamble]:
    Eth.PDU:
     Eth.Header(22Bytes)(14Bytes excluding Preamble+SFD) + Packet(64-18=46, if less than 46-> Padding bytes are added all 0s as Hexa) + Eth.Trailer(4Bytes) 
        Eth.Header:
            {Preamble + SFD(Start Frame Delimiter)}(Usually not considered part of the Eth.Header) + Dst.MAC + Src.MAC +802.1Q[if exists]+ EtherType/Type/Length[Indicates Length of encapsulated data OR L3 Protocol(Internet Protocol v4&v6) + Control]
                Preamble: 
                    Length of 7Byts(86b), 
                    Series of Alternating 1s and 0s 10101010 * 7, 
                    Allows devices to synchronize their receiver clocks to be prepared to receive the rest of the frame
                SFD:
                    Length  of 1Byt(8b),
                    Series of Alternating 10101011 * 1,
                    Marks the end of the Preamble and beggining of the rest of the frame
                Dst.&S. MAC:
                    Length of 6Bytes(48b = 6Bytes = 2Hex for each Byte = 12Hex with 4b in each) for each, as is the MAC address
                    Indicates the devices sending and receiving the frame
                    Consists of MAC(Media Access Control) address of the physical device
                    MAC: "mac-address NewTempMAC"
                        Assigned to the device when it is made
                        A.K.A 'Burned-In Address' BIA
                        Globally unique
                        1st 3Bytes/6Hex(24b) are the OUI(Organization Unique Identifier)
                        2nd 3Bytes/6Hex(24b) = 2**24 for possibilities) are unique to the device itself(Vendor assigned)
                        Written as 12 Hexa(10s place represents 16 in Hexa)
                EtherType/Type/Length:
                    Lenght of 2Byte(16b),
                    A value of:
                        1500Byte or less->    indicates the length of the encapsulated packet(in Bytes)
                        1563Byte or greater-> indicates the type of the encapsulated packet
                            Type Codes-> IPv4 = 0x0800 = (2048) Decimal / IPv6 = 0x86DD = (34525) Decimal / ARP = 0x0806 = (2054) Decimal) and the length is determined via other methods
                Control:
                    Identifies special flow control services such as QoS.
        Eth.Trailer:
            FCS(Frame Check Sequence)[Used by receiving device to detect any error that might occured during transmission]
            Length of 4Bytes(32b),
            Detects corrupted data by running 'CRC(Cyclic Redundancy Check)' algorithin over the received data
        Types of Frames:
            Unicast: A frame destined for a single target
                Unknown Unicast frame: SW Floods the frame multicasting to its interfaces except the one received from as it has no known MAC address in the table, and never learn that Dst.MAC unless it sends a frame
                Known Unicast frame: SQ Forward it, A known MAC in the address table, and matches with an incoming frame's destination
            
    switching: "show mac address-table", "clear mac address-table dynamic/dynamic address MACAddress/dynamic interface InterfaceName"
     After a SW receives a Frame, it saves the Dst.MAC in a MAC table[content addressable memory (CAM) table] (Dynamically learned, removed after 5Min/300Sec of traffic inactivity from this device[Aging-time]) with the interface it came from
        ARP(Address Resolution Protocol): on a host->"arp -a" / on R->"show ip arp" to reveiw ARP table [Type-> Dynamic(Learned via ARPs), Statick(Default entry)]
        Automatic ARP table are time stamped. If no interaction from a particular device before the timestamp expires(Depends on the OS of the device), the entry is removed from table.
        Static ARP entries do not expire over time and must be manually removed. "arp -s IPAddress MACAddress"
        Discovering L2 Address(MAC) with a known L3(IP) address. 
            When a PC sends data, it uses IP addresses, however, SW operates in L2 addressing MACs. So, Sending PC needs to discover the MAC for the Dst. before forwarding data to SW
            ARP request: Senecccclvevlcfunrluhtidnvkrineduvtdnhlrfvfnr
            ent BC(Sent to all devices, limited to the local network) [S.IP(PC1) + Dst.IP(PC2 inside LAN/DGway if out of LAN) + Src.MAC(PC1) + Dst.MAC(ffff.ffff.ffff.ffff)]
            ARP reply: Sent Unicast(Sent to the host that has sent the request) [S.IP(PC2/DGway) + Dst.IP(PC1) + Src.MAC(PC2/DGway) + Dst.MAC(PC1)]
            Graitous ARP: Putting a new R, will send a BC to all devices in network to clear old R MAC from cache and replace it with the new R's

        Ping(5 in CISCO, 4 in CMDs): "ping 192.168.1.1 size 36", "ping 192.168.1.1 -n 10", "ping 192.168.1.1 -l 40000", "ping 192.168.1.1 -t", Standard ping sends 100Bytes
            Network utility used ot test reachability, 1st ping uses ARP/ND first to know the MAC for the targeted ping
            Measures roud-trip time. "." indicates failed ping, "!" indicates a successful ping.
            Types:
                Pinging the local loopback: 
                    Test the internal configuration of IPv4 or IPv6 on the local host (127.0.0.1 for IPv4 (::1 for IPv6)). response comes from the network layer.
                    This response is not, however, an indication that the addresses, masks, or gateways are properly configured. An error indicates that TCP/IP is not operational on the host.
                Pinging the DGway:
                    Test the ability of a host to communicate on the local network.
                    A successful ping to the DGway indicates that the host and the R interface serving as the DGway are both operational on the local network.
                    If the DGway address does not respond, a ping can be sent to the IP address of another host on the local network that is known to be operational.
                    If the DGway does not respond but another host does, this could indicate a problem with the R interface serving as the DGway.
                Pinging the remote host:
                    Test the ability of a local host to communicate across an internetwork. The R uses its IP routing table to forward the packets.
                    A successful, confirms communication on the LAN, the operation of the R serving as the DGway, and the operation of all other Rs that might be in the path.
            Communication:
                ICMP echo request(5 requests): Unicast
                ICMP echo reply(5 replies): Unicast
            Feedbacks:
                Request Time out/Destination unreachable: Dead, FireWall, Congestion
                Reply from: Successful
                Destination is unreachable/General Failure: Have no connectivity on eachother
            Pinging an IPv6 LLA from a R, IOS will prompt for the exit interface. Because the Dst.LLA can be on one or more of its links or networks, 
                the R needs to know which interface to send the ping to.
        Traceroute(Test the Path):
            Network utility that generates a list of hops that were successfully reached along the path. Sends 3 pings to each hop in the path.
            Round Trip Time (RTT):
                For each hop along the path and indicates if a hop fails to respond. It is the time a packet takes to reach the remote host and for the response to return. 
                An asterisk (*) is used to indicate a lost or unreplied packet.
                If the display shows high response times or data losses from a particular hop, this is an indication that the resources of the R or its connections may be stressed.
            IPv4 TTL and IPv6 Hop Limit:
                Uses a function of the TTL/Hop Limit in the Layer 3 headers, along with the ICMP Time Exceeded message.
        Forwarding: Some SWs are configured to perform cut-through on a per-port basis until a user-defined error threshold is reached, and then they automatically change to store-and-forward. When the error rate falls below the threshold, the port automatically changes back to cut-through.
            Store-and-forward switching: Receives the entire frame and computes the CRC. If the CRC is valid, the SW looks up the destination address, Then the frame is forwarded.
            Cut-through switching: Forwards the frame before it is entirely received. At a minimum, the Dst.MAC[located in the first 6bytes of the frame following the preamble] of the frame must be read before the frame can be forwarded.
                Fast-forward switching: Offers the lowest level of latency. Immediately forwards a packet after reading the Dst.MAC before the entire packet has been received, And the destination NIC discards the faulty packet upon receipt. Latency is measured from the first bit received to the first bit transmitted.
                Fragment-free switching: SW stores the first 64 bytes of the frame before forwarding. Most network errors and collisions occur during the first 64 bytes. Tries to enhance fast-forward switching by performing a small error to ensure that a collision has not occurred before forwarding the frame. It is a compromise between the high latency and high integrity of store-and-forward switching, and the low latency and reduced integrity of fast-forward switching.
        Memory Buffering Methods: when the destination port is busy because of congestion. The SW stores the frame until it can be transmitted.
            Port-based memory: 
                Frames are stored in queues that are linked to specific incoming and outgoing ports.
                A frame is transmitted to the outgoing port only when all the frames ahead in the queue have been successfully transmitted.
                It is possible for a single frame to delay the transmission of all the frames in memory because of a busy destination port.
                This delay occurs even if the other frames could be transmitted to open destination ports.
            Shared memory:
                Deposits all frames into a common memory buffer shared by all SW ports and the amount of buffer memory required by a port is dynamically allocated.
                The frames in the buffer are dynamically linked to the destination port enabling a packet to be received on one port and then transmitted on another port, without moving it to a different queue.
                Results in the ability to store larger frames with potentially fewer dropped frames. This is important with asymmetric switching which allows for different data rates on different ports such as when connecting a server to a 10 Gbps SW port and PCs to 1 Gbps ports.
    Address Grouping:
        Unicast: One device sending a message to one other device in one-to-one communications.
        Multicast: sending a single packet to a selected set of hosts that subscribe to a multicast group.
            Dst.MAC address of 01-00-5E for IPv4 packet AND a Dst.MAC address of 33-33 for IPv6 packet.
            The range for IPv4 is 224.0.0.0 to 239.255.255.255. The range for IPv6 begins with ff00::/8. 
        BC: R by default does not pass BC nor collision. IPv4 uses broadcast packets. However, there are no broadcast packets with IPv6.
            Directed: 
             sent to all hosts on a specific network. For example, a host on the 172.16.4.0/24 network sends a packet to 172.16.4.255. 
                Abuse from malicious users, directed broadcasts are turned off by default starting with Cisco IOS Release 12.0 with the global configuration command "no ip directed-broadcasts".
                All NID specified and HID are 1s = sent to 255.255.255.255
            Limited:  
             Used to let the host search for Network Resources. ie. DHCP.
                All NID and HID are 1s = sent to 172.16.4.255 from the NID 172.16.4.0/24
            Dst.MAC address of FF-FF-FF-FF-FF-FF. Dst.IPv4 has all ones (1s) in the host portion that means all hosts on that local network (broadcast domain) will receive and process the packet.
            255.255.255.255 functions as 192.168.5.127/25 or any subnetwork. And if a host sends information it still will not be sent to all networks, only to the local LAN. 
            But 192.168.5.127/25 can however be used by other networks to send broadcast traffic to this specific subnetwork
            BC domain:
                Hub: 1
                SW: 1
    Collisions:
        Collision domain:
            Hub: 1
            SW: same as number of interfaces. No collision occurs, because SW holds forwarded frames to him in buffer.

11000000.10101000.00000001.00|111111


- IPv4: 
 32b -> written in binary 4 octet(8b=1Byt) -> converted to Decimal dottet notation
 192.168.1.254/24, "/24" = "8+8+8" tells that from LTR 3 octet are the network's portion and remaining is the host's. Rs takes IP address for each interface
 AFRINIC is the Regional Interent Registered(RIR) for Africa which takes IPv4 address space from IANA and then assign them to companies that need them or ISP
    Public: 
     globally routed between internet service provider (ISP) Rs
        1.0.0.0/8	    1.0.0.0     ~ 9.255.255.255     (from class A)
        11.0.0.0/8	    11.0.0.0    ~ 126.255.255.255   (from class A)

        128.0.0.0/16	128.0.0.0   ~ 172.15.255.255    (from class B)
        172.0.0.0/16	172.32.0.0  ~ 191.255.255.255   (from class B)

        192.0.0.0/24	192.0.0.0   ~ 192.167.255.255   (from class C)
        192.0.0.0/24	223.169.0.0 ~ 223.255.255.255   (from class C)
    Private(RFC 1918): 
     Not unique and can be used internally within any network.
        10.0.0.0/8	    10.0.0.0    ~ 10.255.255.255    (from class A)
        172.16.0.0/12	172.16.0.0  ~ 172.31.255.255    (from class B)
        192.168.0.0/16	192.168.0.0 ~ 192.168.255.255   (from class C)
    Characteristics of IPs in general:
        Connectionless: There is no connection with the destination established before sending data packets. Similar to sending a letter to someone without notifying the recipient in advance. 
        Best Effort: Does not require additional fields in the header to maintain an established connection. Because it is Connectinoless, it does not guarantee that all packets that are delivered are, in fact, received as senders are unaware whether Dst.devices are present and functional, received the packets, or able to access and read the packet.
        Media Independent: operates independently of the media that carry the data at lower layers of the protocol stack (packets can be communicated as electronic signals over copper cable, as optical signals over fiber, or wirelessly as radio signals)
    Major Issues:
        IPv4 address depletion: IPv4 has a limited number of unique public addresses available.
        Lack of end-to-end connectivity: NAT provides a way for multiple devices to share a single public IPv4 address. However, because it is shared, the IPv4 address of an internal network host is hidden. This can be problematic for techs that require end-to-end connectivity.
        Increased network complexity:    NAT created additional complexity in the network, creating latency and making troubleshooting more difficult.
    IPv4 component:
        Revision:
            Decimal: 3294 -> 3*1000 + 2*100 + 9*10 + 4*1
            Hexa:    CDE  -> C*16*16 + D*16 + E*1
            Binary:  11000000 -> 1*128 + 1*64 + 0*32 + etc.
        Src.IP & Dst.IP: each represent 4Bytes(32b) in length
        192.168.1.254(Dotted decimal) -> 8b.8b.8b.8b -> 11000000.10101000.00000001.11111110(Binary octet) -> Each octet in decimal ranges from 0 ~ 255(if all bits are 1s) 
        AND(Multiplication): 0 AND 0 = 0 | 0 AND 1 = 0 |  1 AND 0 = 0 | 1 AND 1 = 1
            The IPv4 address is logically ANDed, bit by bit, with the subnet mask.
        Network = IP AND Subnet
        Classes: for users 1~223.0~255.0~255.0~255
            A: 0.0.0.0 ~ 127.255.255.255
                1st Octet(Leading bits 0)    0xxxxxxx - Num. range 001-126 - Subnet /8  (255.0.0.0) -   No. of Networks (2**(8-1)) - Addresses per Network (2**(32-8)-2[for BC&Network]) 
                001-126 instead of 0-127 
                (127.0.0.1 ~ 127.255.255.254 are loopback/localhost addresses, checking on TCP/IP stak, can be put in DNS IP in a server settings, ping 127.0.0.1 replies on the TCP/IP installation, and to test NetworkStack on the local device)
            B: 128.0.0.0 ~ 191.255.255.255
                1st Octet(Leading bits 10)   10xxxxxx - Num. range 128~191 - Subnet /16 (255.255.0.0)-  No. of Networks (2**(16-2)) - Addresses per Network (2**(32-16)-2[for BC&Network])
                (169.254.0.0/16 or 169.254.0.1 ~ 169.254.255.254 are Link-local addresses knows as Automatic Private IP Addressing (APIPA), used by Windows DHCP client to self-configure in the event that there are no DHCP servers available)
            c: 192.0.0.0 ~ 223.255.255.255
                1st Octet(Leading bits 110)  110xxxxx - Num. range 192~223 - Subnet /24 (255.255.255.0)-No. of Networks (2**(24-3)) - Addresses per Network (2**(32-24)-2[for BC&Network])
            D: 224.0.0.0 ~ 239.255.255.255
                1st Octet(Leading bits 1110) 1110xxxx - Num. range 224~239 - ---------- - Reserved for Multicast addresses for network programming. EIGRP(224.0.0.10), OSPF(224.0.0.5), etc. Netsupport school desktop.
            E: 240.0.0.0 ~ 255.255.255.254 [255.255.255.255 is reserved for BC]
                1st Octet(Leading bits 1111) 1111xxxx - Num. range 240-255 - Subnet /32 - Reserved for Experimental for IANA researches. 
        Subnet Mask: Network bits = 1 & Host bits = 0. /prefix length in a “slash notation” = number of network bits set to 1 in the subnet mask.
        The actual process used to identify the network portion and host portion from subnetmasks is called ANDing.
            Class A: 11111111.00000000.00000000.00000000 = 255.0.0.0
            Class B: 11111111.11111111.00000000.00000000 = 255.255.0.0
            Class C: 11111111.11111111.11111111.00000000 = 255.255.255.0
        Network: If Host portion is all 0s = Network address, cannot be assigned to a host. First usable address is adding 1 to the most-right bit in host portion.
        Boradcast: If Host portion is all 1s = BC address, cannot be assigned to a host. Last usable address is subtracting 1 from the most-right bit in host portion.
        Interfaces: "show ip interface brief" interfaces in R, "show interfaces InterfaceNameOptional", "description ##YourDesc##" -> "show interfaces description"
            Configuring: "conf t" -> "in gig0/0" -> "ip address TheAddress SubnetMaskInDottetDecimal" -> "no shutdown"
            R interfaces Layer1(Cable attached) status are 'administratively down' by default, "shutdown" applied by default, protocols are at Layer2(Ethernet)
            SW interfaces 'NOT administratively down' by default, they are either 'up/up' or 'down/down'
        IANA: assigns IPv4 addresses/networks to companies based on their size.




- SW Interfaces: 
 Modular SW-> f[fastEthernet]0[slot]/1[port]
    R: 8 SFP interfaces for fiber-optic and the rest are RJ-45
    SW: 4 SFP and the 48 are RJ-45
    Interfaces: "show ip interface brief", "show interfaces InterfaceNameOptional", "show interfaces status" 
    requires no configuratoin and once connected to a device becomes 'up/up', "interface range f0/5-6, f0/7-12"->"desc ## not in use##"->"shutdown" to disable them->'administratively down'
    "show interfaces InterfaceNameOptional": 
        Runts: Frames smaller than the Min. Frame size(64Bytes)
        Giants/babyGiantFrame: Frames larger than the Max. Frame size(1518Bytes)
        CRC: Frames failed the CRC check(in the Eth. FCS trailer)
        Frame: Counts frames that have an incorrect format(due to an error)
        Input errors: Total of various counters, such as the above four
        Output errors: Frames the SW tried to send, but failed(due to an error)
    Duplex: 'a-', "speed 100"->'100x`x' because manually, auto-negotiated with the neighbour device
        Full: Can send and receive data at the same time, does not have to wait
        Half: Cannot send and receive data at the same time, if receiving must wait before sending a frame
        Collision Domains: in HUBs(Operates at L1) if two frames are being sent it results in a collision and none of them will be flooded. 
            With CSMA/CD(Carrier sense multiple access with collision detection)-> Before sending, devices listen to the collision domain untill they detect others are not sending at the moment. If a collision occur, the device sends a jamming signal to inform others that of it, each device will wait a random period of time before sending and the processed repeats.
        Auto:
            - if SW sensed speed of 10Mbps OR 100Mbps, SW will use Half-Duplex. If sensed 1000Mbps(1Gbps) OR greater, SW will use Full-Duplex.
            - if SW sensed speed of 100, will use half-duplex. But if the device uses full-duplex, a Duplex mismatch collisions will occur
    Speed: 'a-', "duplex full"->'full' because manually, auto-negotiated with the neighbour device
        Auto: Interfaces that can run (10/100 OR 10/100/1000) are 'speed auto' & 'duplex auto' by default. 
            - Interface advertise their capabilities to the neighbouring device, and they negotiate the best SPEED & DUPLEX they are both capable of
            - If auto disabled on a device, SW will try to sense its speed, if fails to sense will use the slowest supported speed on its interface.
        E=10, f=10/100, G=10/100/1000




- IPv4 header: 
 20 octets. Min.Length(20Bytes), Max.Length(60Bytes). 12 basic header fields.
    Version/IHL+DS/DSCP/ECN+TotalLength+IdentificationField+Flags+FragmentOffset+TTL+Protocol+HeaderChecSum+Src.&Des.IP+Options/paddings
    Version: 
        Length of 4b binary value, half of one octet
        Identifies the version of IP used, 
            IPv4=4(0100), IPv5=Expremental(Never published), IPv6=6(0110)
    IHL(InternetHeaderLength): 
        Length of 4b, half of one octet
        Necessary to indicates the total length of the header because final field (Options) is variable in length, calculates it in 4Byte increaments(
            If value is 5[Min.Value, with empty options field] = 5*4 = 20Bytes | 
            15[Max.Value, 4b all filled with 1s-> 1111=15] = 15*4 = 60Bytes)
    DS(Differentiated Services/DiffServ)[Formerly ToS]:
        Length of 8b, the 6 most-significan bits are DSCP, and last 2 are ECN
        Used for QoS(Quality of service), to prioritize delay-sensitive data
        DSCP(Differentiated Services Code Point):
            Length of 6b
            Used for QoS(Quality of service), to prioritize delay-sensitive data
        ECN(Explicit Congestion Notification):
            Length of 2b
            Provides end-to-end notification of network congestion without dropping packets
            Optional feature, requires both endpoints and infrastructure to support it
    TotalLength: Min. Value(20Bytes)=IPv4 with no encapsulated data, Max. Value 16b all filled with 1s=65,535
        Length of 16b
        Indicates the total length of the packet (L3 header+L4 Segment)
        Measured in Bytes, not increamental like IHL
    IdentificationField:
        Length of 16b
        Used to identify which packet the fragment belongs to(All fragments of same packet will have same value) [If packet larger than MTU[Max. Transmission Unit 1500] gets fragmented fragmented]
    Flags:
        Length of 3b
        Used to control/identify fragments
            bit0-> Reserved, always set to 0
            bit1-> DF bit(Do't Fragment), to identicate a packet that should not be fragmented. Can be specified with "df-bit" in the command
            bit2-> MF bit(more Fragement), Set to '1' if there are more fragments on the way from the same packet, set to 0 for the last fragment
    Fragment Offset:
        Length of 13b
        Indicates a position of a fragment within the original IP packet to be reassembled even if arriveed out of order
    TimeToLive: Recommended default TTL is 64
        Length of 8b
        A R will drop a packet with a TTL of 0 second(And R sends an ICMP TimeExceeded to the Src.host)
        used to prevent loops at L3
        in practice, indicates a 'hop count', each time the packet arrives at a R, TTL decreased by 1 until the packet arrives its Dst. or dropped if has gotten to 0
    Protocol: 
        length of 8b
        indicates the protocol of the encapsulated L4PDU
            Value of 6: TCP
            Value of 17: UDP
            Value of 1: ICMP
            Value of 89: OSPF(Dynamic routing protocol)
    Header Checksum:
        Length of 16b
        Receiving R calculates the checksum of the header and compares it to the one in this field, if they do not match, the R drops the packet
        Checks error only in the IPv4 header, IP relies on the encapsulated protocol to detect errors in the encapsulateed data
        Both TCP&UDP have their own checksum fields to detect errors in the encapsulated data
    Src.&Dst. IP:
        Length of 32b each
        Src.IP = IPv4 address of the sender and always unicast, Dst.IP = IPV4 address of the intended receiver and might be Unicast/Multicast/BC
    Options:
        length of 0-320b
        if IHL is greater than 5, it means that options are present




- Routing:
 The process that Rs use to determine the path that IP packets should take over a network to reach their Dst..
    Determination: 
     The Src.host determines if the Des.IP on same network or remote
        In IPv4: 
            The Src. uses its own subnet mask, IPv4 address, and the Dst.IPv4 to make this determination.
        In IPv6: 
            The local R advertises the local network address (prefix) to all devices on the network.
    Auto-Configured routes: 
        When you enable it with 'no shutdonw', 2 routes(per interface) will automatically be added to the routing table
        Configuration:
            R#conf t -> R(conf)#interface g0/0 -> R(conf-if)#ip address TheIpAddress TheNetmaskDecimalDottet -> R(conf-if)no shutdown
    Functionality:
        Tells the R, 
        - To send the packet to Dst. X, you should send the packet to next-hop[next R in the path to Dst.].
        - If the Dst. is directly connected(C) to the R, send the packet directly to Dst..
        - If the Dst. is the R's own IP address(L), receive the packet for yourself[Do not forward it].
    Matching route: 
        A route matches a packet's Dst. if the packet's Dst.IP address is part of the network specified in the route
        R drops the packet if there is no matching route
    Routing tables:
     Storing routes to all known Dsts..
     IPv4 and IPv6 has two different routing table in a R.
        R#show ip route, 
    Interfaces:
        Loopback interfaces:
            A virtual interface in a R, and always up/up
            Provides a consistent IP address that can be used to reach/identify the R
            NOTE: 
                - Loopback interface are virtual interfaces on a device and can be reached by other devices.
                - Looback addresses are virtual addresses on the local device and cannot be reached by other devices.
        Serial Interfaces:
            One side functions as a Data Communications Equipment(DCE), the other side functions as a Data Terminal Equipment(DTE)
            On DCE side, clock-rate(Speed) needs to be specified of the connection
            Default encapsualtion on serials is HDLC with a frame-> [address(8b) + control(8b) + protocol code(16b) + information(0 or more bits, in multiple of 8) + FCS(16b) + flag(8b)]
            Configuration:
                R1(config)#interface s/0
                R1(config-if)#clock rate bps
                R1(config-if)#encapsualtion ppp     [Must match on both ends or the interface will go down]
                R1#show controllers s2/0    [To see which side is DCE/DTE]
                NOTE: Ethernet interfaces use the 'speed' command to configure the interface's operating speed. Serials use the 'clock-rate' command.
    Route selection: 
        - If a packet destined for 192.169.1.1 is matched by both routes (192.168.1.0/24 & 192.168.1.1/32). 
            R will choose the most specific matching route(Longest prefix length):
                - The route to 192.169.1.0/24 includes 256 different IP addresses (192.169.1.0 ~ 192.169.1.255),
                - The route to 192.169.1.1/32 includes 1 IP address (192.169.1.1) [More specific]
    2-Way reachability: 
     PC1 and PC4 can send packets in both two ways. Means, each R in the path needs two routes(a route to PC1 & a route to PC4).
     "iface eth0 inet static" 
        - DGway(Default R)(Last resort): 
            S*-Defualt Route: 
             A route a host will take when it tries to contact a remote network
             Traffic to Dsts. outside of the internal network is sent to the internet. Often used as defult route to direct traffic to internet
                Configuratoin:
                    R#ip route 0.0.0.0 0.0.0.0 exitInterfaceName/nextHubIpAddress/exitInterfaceName nextHubIpAddress
                        a route to 0.0.0.0/0 = all netmask bits set to 0. 
                        Includes all addresses from 0.0.0.0 to 255.255.255.255 [Least specific route possible, because it includes all IP address]
                Functionality:
                    - PC1 can send packets directly to Dsts. in their connected network via SW.
                    - However, to send packets destined outside of their local network, they must send it to their DGway.
                        - Src.IP: PC1, Dst.IP: PC4, Dst.MAC: PC1's DGway's interface's MAC(learned via PC1 ARP requested), Src.MAC: PC1 eth0 MAC,
                        - Then, R1 de-encapsulates the packet(Removes L2 Header/Trailer) and look inside the packet, and make a desicion from its routing table,
                            = R forwards packets using default route If does not have any more specific routes that matches a packet's Dst.
                            = If more than next-hop, it can [Load-Balance] between more than one path. OR Use one path as main, and others as a [Backup-path]
        NOTE: 
            - More Specific routes used for Dsts. in the internal networks should be configured manually.
            - Src.&Dst. MAC changes throughout the journey to Dst., and only matches the Dst.IP on last R. Src.&Dst.IPs do not change.
    Types:
        Dynamic routing: 
         Shares routing info about their connected routes and routes they learned from other devices with each other and any changes on the network. 
         - If a path to specific network has a failure, it removes it from the table to prevent sending traffic to a dead-end
         - They form neighborships with adjancent to its directly connected Rs to exchange this info
         - If multiple routes to a single Dst. are learned, the R determines which route is superior and adds it to the routing table using the "metric" [Lower metric = superior]
         - Network administrator required to enable "the directly connected networks" within the dynamic routing protocol.
            Routes:
                Network Route(C[Connected]):
                    A route to a network/subnet (mask length < /32)
                Host routes(L[local]):
                    A route to a single host specified with a (/32 mask)
            Administration Distance(AD):
             The AD is used to determine which routing protocol is preferred. A lower AD is preferred, and indicates that the routing protocol is considered more 'trustworthy'.
                = If two companies connect their network to share info, two different routing protocols might be in use. 
                = But, "Metric" is used to compare routes learned via same routing protocol 
                Routes protocols' AD:
                    Directly connected:     0
                    Static:                 1
                    EIGRO summary router:   5
                    External BGP(eBGP):     20
                    EIGRP:                  90
                    IGRP:                   100
                    OSPF:                   110
                    IS-IS:                  115
                    RIP:                    120
                    EIGRP(External):        170
                    Internal BGP(iBGP):     200
                    Unusable route:         255 [The R does not believe the Src. of that route and does not install it in its routing table]
                Manual manipulation:
                        R(config)#ip route IpAddress NetMask ExitInterface AD (If lower AD configured and became less preferred, it is called 'floating route') 
                        NOTE:
                            = Floating routes will be inactive unless the lower learned route is removed/down
            Equal cost multi-path(ECMP):
                = If a R learns two or more routes via the "same routing protocol" to the "same Dst." with the "same metric", 
                = both will be added to the routing table and traffic will be load-balanced. Can be used in static routes too, metric will have vlaue of "0"
            Classes:
                Classfull: Routing Protocol does NOT support subnetting  /8,16,24    [RIPv1, only /8,16,24 is able to understand]
                Classless: Routing Protocol does support subnetting      /10,20,26  [RIPv2, EIGRP, OSPF]
            Types:
                Interior Gway Protocol(IGP):
                 Shares routes within a single autonomous system(AS), which is a single Org(Company)
                    Algorithm:
                        Distance Vector:
                         Rs only learn the "distance" = "metric" and the "vector" = "direction, next-hop R" of each R.
                            Functionality:
                             Operates by sending the following to their directly connected neighbors:
                                - Their known Dst. networks
                                - Their metric to reach their known Dst. networks
                                NOTE: 
                                 = This method known as "routing by rumor". Because the R does not know about networks beyond its neighbors, it only knows the info that its neighbors tell it.
                            Metric:
                                RIP:    
                                    = [Hop count]. 
                                    = Each R in the path counts as one 'hop'. Total metric is the total number of hops to the Dst.. 
                                    = Donwsides: 
                                        = Links of all speeds are treated equally, counted as 'one hop' whatsoever. Max. hop count is 15, anything more than that is concidered unreachable.
                            Types:
                                - Interior GWay Routing Protocol(IGRP):
                                - Routing Information Protocol(RIP):
                                 Symbol in Routing-Table is "R"
                                    = Versions: 
                                        v1:
                                            = Classful advertising only (Class A, B, C) [Therefore, Does not support VLSM, or CIDR] 
                                                172.16.192.0/18 will be assumed class B and becomes 172.16.0.0/16
                                            = Does not include subnet mask info in the advertisiment response message
                                            = Messages updates are sent BC 255.255.255.255
                                            = No Authentication   
                                        v2:
                                            = Classles [Supports VLSM, CIDR]
                                            = Includes subnet mask info in the advertisiment response message
                                            = Messages updates are sent multicast 224.0.0.9
                                            = Authentication is enabled to verify the device sending routing-table info
                                        RIPng(next generation):
                                    = Messages:
                                        Request message: Asking RIP-enabled neighbor R to send their routing table
                                        Response message:To send the local R's routing table to neighboring Rs
                                        NOTE: 
                                            = by default they share their routing info every 30Sec over multicast 224.0.0.9
                                    = Characteristics:
                                        = AD is "120"
                                        = Metric is "Hop Count"
                                        = Max Hop count "15 Rs"
                                        = Sends update periodic is "30Sec"
                                        = Sends Full Routing-Table (Wastes BW)
                                    = Configuration:
                                        = RIP router:
                                            R(config)#router rip
                                            R(config-router)#version 2
                                            R(config-router)#no auto-summary                    (to enable classes routes)
                                            R(config-router)#network DirectConnectedNetwork [wildcard]
                                            R(config-router)#network 0.0.0.0 255.255.255.255    (means all networks C to this R)
                                            R(config-router)#passive-interface interfaceToStopSendingUpdateTo
                                        = DGway:
                                            R1(config)#ip route 0.0.0.0 0.0.0.0 203.0.113.2     (Configuring last resort on one R)
                                            R1(config-router)#default-information originate     (To my R to advertise the configured last resort to its neighbors)
                                        = Manipulations:
                                            R1(config-router)#maximum-path <1~32>               (ECMP load-balancing, means how many to insert for multiple paths to same network with same metrics. Can be used for RIP, EIGRP, and OSPF)
                                            R1(config-router)#distance <1~255>                  (to change the default AD of any protocol)
                                            R1(config-router)#rip router-id {theID}             (to manually configure R ID)
                                            R(config)#no ip route x.x.x.x x.x.x.x serialx/x/x   (to cancel static routing)
                                        = Displays:
                                            R#show ip protocols                                 (to check protocols. Can be used for RIP, EIGRP, and OSPF)
                                            R#show ip rip neighbors                             (to check neighbors. Can be used for RIP, EIGRP, and OSPF)
                                            R#show ip rip topology                              (to check the topology. Can be used for RIP, EIGRP, and OSPF)
                                            R#show ip route FullNametypeOfRoute                 (to check specific type of route)
                                    = NOTE: 
                                        = 'network' command is classfull, even if you enter the command "network 10.0.12.0" it will be converted to "network 10.0.0.0" (Class A)
                                        = Then it looks for interfaces with an IP that is in match of the entered network range and active RIP protocol on them. [10.0.12.1 and 10.0.13.1 both match]
                                        = It then forms adjacencies with connected RIP neighbors and advertise the network prefix of the interfaces (not the prefix in the 'network' command)
                                        = In case of networks that has no R neighbors on them, you should configure them as "passive" to prevent unnecessary traffic update sent by RIP every 30Sec
                                        = Wildcard mask: 
                                            inverted subnet mask, all 1s in subnet are 0s in equivilant wildcard and vice versa. 
                                            '0' in wildcard = "must match", '1' = "do not have to match".
                                            The matching process is between the {Interface IP} and the {IP enterd in the 'network'} command in reference to the wildcard 0s and 1s, example:
                                                Wildcard:                       00000000.00000000.00000000.0000|1111
                                                R1 G2/0 :                       10101100.00010000.00000001.0000|1110
                                                'network' command enterd IP:    10101100.00010000.00000001.0000|0000
                                            i.e.:
                                                /19 = 11111111.11111111.11100000.00000000 = 255.255.224.0 -Becomes--> 00000000.00000000.00011111.11111111 = 0.0.31.255
                                                OR, just subtract each decimal dotet from 255 and write the remaining. 
                        Diffused Update Algorithm(DULA)
                            Metric:
                                EIGRP:  
                                    = Bandwidth & delay. 
                                    = By default, the bandwidth of the "slowest link in the route" and the total delay of all links in the route.
                                    = Formula: ([K1 * bandwidth + (K2 * bandwidth) / (25 - load) + K3 * delay] * [K5 / (reliability + k4)]) * 256
                                        = Default values of 'K': K1=1. K2=0, K3=1, K4=0, K5=0
                                    = Unequal-Cost Load-Balancing:
                                     EIGRP will only performs over "Feasible Successor" routes. 
                                     If a route doesn't meet the feasiblity requirement, it will NEVER be selected regardless of the "Variance"
                                        = EIGRP maximum metric variance 1: 
                                            '1' = only ECMP load-balancing will be performed, 
                                            '2' = "Feasible Successor" routes with an FD up to 2x the "Successor" route's FD can be used to load-balance
                                        = Feasible Distance = This R's metric value to the R's Dst.
                                        = Reported Distance(Advertised Distance): The neighbor's metric value to the route's Dst.
                                        = Successor: The route with the lowest metric to the Dst. (The best route)
                                        = Feasible successor: An alternate route to the Dst. (Not the best route, but meets the feasiblity condition)
                                            Feasiblity Condition: 
                                                A route is considered a feasible successor if its "Reported Distance" is lower than the successor route's "Feasible Distance"
                            Types:
                                Enhanced Interior GWay Routing Protocol(EIGRP):
                                 Cisco proprietary protocol update for IGRP, and now partially published openly so other vendors can used.
                                    Functionality:
                                        Considered an advanced/hybrid distance vector routing protocol and much faster than RIP in reacing to changes in the network.
                                        Does not have the 15 hop-count limit, sends messages update using multicast 224.0.0.10, and performs unequal-cost load-balancing (default maximum-path is 4)
                                    Configuration:
                                        = Setting up:
                                            R(config)#router eigrp ASNumber
                                            R(config-router)#no auto-summary
                                            R(config-router)#network DirectConnectedNetwork
                                            R(config-router)#egirp router-id theRouterID
                                            R(config-router)#passive-interface interfaceToStopSendingUpdateTo
                                        = Displays:
                                            R#show ip eigrp
                                            R#show ip eigrp neighbors
                                            R#show ip eigrp interfaces
                                            R#show ip eigrp topology
                                            R#show ip route eigrp
                                            R#show ip protocols
                                        NOTE: 
                                            = AS is the autonomous system number, and it must match between Rs or they will not form an adjacency and share route info.
                                    R ID:
                                     In EIGRP and OSPF, a unique ID to identify the R within the AS. Order of selecting R ID priority:
                                        - Manually configured 
                                        - Highest IP on a loopback interface
                                        - Highest IP on a physical interface 
                        Link State:
                         Every R creates a 'connectivity map' of the network. 
                            Functionality:
                                Each R advertises info about its interfaces(connected networks) to its neighbors, until all Rs develope the same map of the network.
                                Then, each R independently uses this map to calculate the best routes to each Dst. 
                                Uses more resources(CPU) on the R, because more info is shared than DV. Faster in reacting to changes in the network than DV protocols.
                            Metric:
                                OSPF:
                                    = Cost, based on bandwidth
                                    = The total metric is the total cost of each link in the route.
                                IS-IS:  
                                    = Cost
                                    = The total metric is the total cost of each link in the route. The cost of each link is not automatically calculated by default. 
                                    = All links have a cost of 10 by default.
                            Types:
                                Open Shortest Path First(OSPF):
                                    = Properties:
                                        Open Shortest Path First
                                        Admin = 110
                                        Metric(cost) = Bandwidth [10**8 / Lowest Bandwidth in the path]
                                        Classless
                                        Quick Convergence (Triggered update)
                                        send updates multicast (224.0.0.5[OSPF Rs] - 224.0.0.6 [DR-BDR])
                                        Multi vendor
                                        Unlimitd hop count
                                        Support Authentication
                                        Uses SPF algorithm
                                    = Versions: 
                                        1 [Old, not in use anymore]. 
                                        2 [Used for IPv4]. 
                                        3 [Used for IPv6, and can also be used for IPv4]
                                    = Storage:
                                        = Rs store info about the network in Link State Advertisements(LSAs), which are organized in a stracture called Link State Database(LSDB)
                                        = Each R 'floods' LSAs until all Rs in the [OSPF area] develope the same map of the network (LSDB)
                                        = Flooding:
                                            R's interfaces create an LSA to tell its R neighbor about the network connected to it [RID, IP, and Cost]
                                            LSA is then flooded throughout the network until all Rs have received it, resulting all Rs sharing same LSDB and becomes identical [Complete map of the whole network]
                                            Then each R uses the OSPF algorithm to calculate its best route to the new network in the shared LSA
                                            NOTE: 
                                                = Each LSA ages after 30Min, and gets flooded again after the timer expires
                                    = Process:
                                        1- Becoming neighbors with other Rs connected to the same segment
                                        2- Exchange LSAs with neighbor Rs
                                        3- Calculate the best routes to each Dst., and insert them into their into the routing table
                                    = Areas:
                                     A set of Rs and links that share the same LSDB
                                        = Area 0(Backbone):
                                            All other areas must connect to
                                        = Rs:
                                            Internal Rs:
                                                Rs with all of their interfaces in the same area
                                            Area Border Routers(ABRs):
                                                Rs with interfaces in multiple areas
                                                They maintain a separate LSDB for each area they are connected to(Recommended to connected an ABR to a max. of 2 areas, to prevent overburden)
                                            Backbone Rs:
                                                Rs connected to/inside area 0
                                            Autonomous System Boundary R(ASBR):
                                                R that connects the OSPF network to an external network. [Wich has 'default-information originate' command enabled on]
                                        = Sizes:
                                            = Small networks can be single-area without any negative effects on performance
                                            = Larger networks, a single-area design can have negative effects:
                                                - SPF algorithm takes more time to calculate routes
                                                - SPF algorithm requires exponentially more processing power on the Rs
                                                - Larger LSDB takes up more memory on the Rs
                                                - Any small change causes every R to flood LSAs and run the SPF algorithm again
                                        = Routes:
                                            Intra-area route:
                                                A route to a Dst. inside the same OSPF area
                                            Inter-area route:
                                                A route to a Dst. in a different OSPF area.
                                        = Rules:
                                            - Areas should be contiguous(Connected) [Cannot have halves of a single area coming from different ABR]
                                            - All OSPF areas must have at least one ABR connected to the backbone area
                                            - OSPF interfaces in the same subnet must be in the same area
                                    = Netowrk Type:
                                     Refers to the type of connection between OSPF neighbors
                                        BC: 
                                         Enabled by default on 'Ethernet' and 'Fiber Distributed Data Interfaces(FDDI)' Interfaces
                                            Functionality:
                                                - Rs dynamically discover neighbors by sending/Listening for OSPF 'Hello Message' using multicast address 224.0.0.5
                                                - A Designated R(DR) and Backup Designated R(BDR) must be elected on each subnet. [Only DR if there are no OSPF neighbors, ie. passive interfaces]
                                                    - Messages to the DR/BDR are multicast using address 225.0.0.6. 
                                                - Rs which are not the DR or BDR become a DROther, and they will not exchange LSAs with each other
                                                - Starting the 'Exstart state', DR and BDR will form a FUll adjacency with all Rs in the subnet. DROthers will form a FULL adjacency only with DR/BDR
                                                - Therfore, Rs(DROthers) only exchange LSAs with DR and BDR. All Rs will still have the same LSDB, but this reduces the amount of LSAs flooding the network
                                                - Timers: Hello 10, Dead 40
                                            DR/BDR election order:
                                                - Highest OSPF interface priority
                                                - Highest OSPF RID
                                            Key points:
                                                - 'First place' becomes the DR for the subnet, 'Second place' becomes the BDR
                                                - DR/BDR election is 'non-preemptive', once role have been selected they will keep their role until OSPF is reset, the interface fails/shut, etc.
                                                - If DR goes down, the BDR takes over. Then an election is held for the next BDR
                                                - The neighbor state with DROthers will be 2-way, and do not form OSPF adjacency
                                                - The default OSPF interface priority is '1' on all interfaces
                                                - Serial link cannot use the BC network type, because Serials do not support L2 BC frames
                                        Point-to-Point: 
                                         Enabled by default on serial interfaces using the 'Point-to-Point Protocol(PPP)' and 'High-level Data Link Control(HDLC)' L2 encapsulation.
                                            Functionality:
                                                - Rs dynamically discover neighbors by sending/Listening for OSPF 'Hello Message' using multicast address 224.0.0.5
                                                - Because they are 'point-to-point', therefore, no point in electing a DR and BDR. The two Rs will form a full adjacency with each other.
                                                - When running 'show ip ospf neighbor', state will be 'FULL/-' because P-t-p does not use DR/BDR/DROther
                                                - Timers: Hello 10, Dead 40
                                        Non-BC: 
                                         Enabled by default on 'Frame Relay' and 'X.25' Interfaces
                                            Functionality:
                                                - Neighbor discovery it needs to be configured manually
                                                - Timers: Hello 30, Dead 120
                                     Configuration:
                                        R1(config)#interface g0/0
                                        R1(config)#ip ospf network typeYouSelected
                                    = Metric:
                                     OSPF metric is Cost, automatically calculated based on the bandwidth(speed) of the interface
                                        Calculations: 
                                            = 'Reference bandwidth' / 'interface's bandwidth' [Default reference bandwidth is 100mbps]
                                                Reference: 100mbps / Interface: 10mbps(Ethernet) = cost of 10
                                                Reference: 100mbps / Interface: 10000mbps = cost of 1   [Values less than 1 will be converted to 1]
                                            = 'Metric of a route' to a Dst. is the total cost of the 'outgoing/exit interfaces', and if there is a loopback cost it is 1 
                                                assuming we sat the default reference bandwidth to 100000:
                                                    R1's interface to a network on R4-> 100(R G0/0) + 100(R2 G1/0) + 100(G4 G1/0) = 300
                                                    R1's interface to L0 on R2->        100(R G0/0) + 1(R2 L0) = 101
                                            = Cost Manipulations:
                                                Change defualt reference bandwidth with the 'auto-cost reference-bandwidth'
                                                Change the interface bandwidth with the 'bandwidth' command 
                                                Manual configuration of the interfaces with the 'ip ospf cost costNum' commands
                                        NOTE: 
                                            = Changing the interface bandwidth does not actually change the speed at wich the interface operates
                                        Spped: You can change the speed at which the interface operates, with the 'speed' command
                                    = Neighbors:
                                        Requirements:
                                            - Area number must match
                                            - Must be in the same area and same subnet
                                            - OSPF process must not be 'shutdown'   ['shutdown' the process, disables the OSPF without removing the configurations]
                                                R1(config)#router ospf 1 -> R1(config-router)#shutdown ->  R1(config-router)#no shutdown 
                                            - OSPF RID must be unique
                                            - Hello and Dead timers must match
                                                R1(config)#interface g0/0 -> R1(config-if)#ip ospf hello-interval inSec ->  R1(config-if)#ip ospf dead-interval inSec
                                            - Authentication settings must match
                                                R1(config)#interface g0/0 -> R1(config-if)#ip ospf authentication-key yourKey ->  R1(config-if)#ip ospf authentication
                                            - IP MTU settings must match
                                                If this does not match, still can become OSPF neighbors, but OSPF does not operate properly
                                                Default 1500Bytes
                                                R1(config)#interface g0/0 -> R1(config-if)#ip mtu <68~1500>bytes
                                            - OSPF Network type must match
                                        Becoming Neighbors:
                                            - Down: 
                                                R1 sent out a Hello packet(My RID:1.1.1.1, Neighbor RID: 0.0.0.0) to its neighbor R2, 
                                                And now R1&R2 OSPF state in their neighbor talbes is "down"
                                            - Initiate: 
                                                R2 receives the Hello packet(My RID:1.1.1.1, Neighbor RID: 0.0.0.0), from its neighbor R1. 
                                                And now R2 adds R1 in its neighbor talbe as "init"
                                            - 2-way[Testing their compatibility to become neighbors]:
                                             Designated R(DR)&Backup Designated R(BDR) are elected at the completion of this point
                                                R2 sends a Hello packet(My RID:2.2.2.2, Neighbor RID: 1.1.1.1), to its neighbor R1. And now R1 adds R2 in its neighbor talbe as "2-way"
                                                R1 sends a Hello packet(My RID:1.1.1.1, Neighbor RID: 2.2.2.2), to its neighbor R2. And now R2 adds R1 in its neighbor talbe as "2-way"
                                            - DR/BDR Election, and connection between DROthers stop
                                        Exchanging LSAs:
                                            - ExStart[Exchanging DBDs to determine Master/Slave]:
                                             Before beggining this point, they have to choose which one will start the exchange(Master/Slave)
                                             Higher RID is 'Master', and lower RID is 'Slave'. This is determined by exchanging Database Description(DBD) packets
                                                R1 send a DBD packet 'I will be the master', then R2 corrects him with a reply 'No, I will be the master. I have higher RID'
                                            - ExChange[Exchanging DBDs with LSAs]:
                                             Rs exchange Database Description(DBD) with just basic info about their LSAs in their LSDB
                                                R1 & R2 sends DBD packet 'I have these LSAs', 
                                                and each compare the DBD received to the info in their own LSDB to determine which LSAs they must receive from their neghbor
                                            - Loading[Sending LSRs]
                                             Rs sends Link State Request(LSR) to request any LSAs they do not have from their neighbors 
                                                R1 & R2 sneds LSR 'Give me these LSAs', and both replies with the requested LSAs inside a Link State Update(LSU) message, 
                                                and whoever receives the LSU from the other replies with Link State Acknowledgment(LSAck)
                                            - Full[DR-DrOther]:
                                                Rs have a full OSPF adjacency and identical LSDBs. 
                                                They continue to send and listen for Hello packets(Every 10Sec) to maintain neighbor adjacency
                                                Each time a Hello packet is received, the 'Dead' timer(40Sec) is reset. If 'Dead' counts zero, the neighbor is removed.
                                    = Messages:
                                     OSPF messages are encapsulated in an IP header, with a value of 89 = 0x59 in the 'protocol' field
                                     Sent over multicast 224.0.0.5   [Mutlicast address for all OSPF Rs, 224.0.0.6 between DRs/BDRs]
                                        Hello message: 
                                         For neighbor discovery and maintenance
                                            Fields:
                                                Version Number: version of OSPF
                                                Type: 1 [OSPF message type]
                                                Packet length
                                                RID
                                                Area ID: dotet decimal
                                                Checksum
                                                Auth Type
                                                Authentication
                                                Network mask
                                                Hello interval
                                                Options
                                                RP
                                                R dead interval
                                                DR IP
                                                BDR IP
                                                Neighbor ID
                                            Neighbor Conditions:
                                                - Direct connection
                                                - Located on same area
                                                - Having same authentication
                                                - Having same hello message time sycle (10Sec) & hold down time (4 times = 40Sec)
                                        Database Description(DBD): summary of LSDB, to check if LSDBs are same on both Rs. Defined in a hex number [Default 0x80000000]
                                        Link-State Request(LSR): Requests specific LSAs detailed info from the neighbor
                                        Link-state Update(LSU): Sends specific LSAs to the neighbor
                                        Link-State Acknowledge(LSAck):
                                         Used to acknowledge that the R received a message. There are 11 types, and those are top 4:
                                            LSA type 1(R LSA): 
                                                Generated by all OSPF Rs, identifies the R using its RID, and also lists networks attached to the R's OSPF-activated interfaces
                                            LSA type 2(Network LSA): 
                                                Generated by DR of each 'multi-access' network(ie. BC netowrk type), lists Rs are attached to the 'multi-access network
                                            LSA type 3(Summary LSA): 
                                                Sent by ABR only, between different areas, and contains summary info about networks
                                            LSA type 5(AS External LSA): 
                                                Generated by ASBRs only, describes routes to Dst. outside of the AS(OSPF domain)
                                    = Tables:
                                        Neighbor Table: Contains neighbors information 
                                            show ip ospf neighbor
                                        Database Table: Contains network information
                                            show ip ospf db
                                        Routing Table:  Contains best path for each network
                                            show ip ospf route       
                                    = R ID: 
                                     Identifier for Rs in OSPF area
                                        1- Static:
                                            R ospf 0 -> router-id 1.1.1.1
                                        2- Highest IP for loopback interface(Virtual Interface used for test)
                                            interface loopback 1 -> ip address xxx.xxx.xxx.xxx xxx.xxx.xxx.xxx
                                        3- Highest IP for physical interface in "Active" state:
                                            f0/0
                                            g0/0
                                            s0/0/0
                                    = Configurations:
                                        = Per R:
                                            R(config)#router ospf 1(process ID)
                                            R(config-router)#router-id 1.1.1.1
                                            R(config-router)#network DirectConnectedNetwork {wildcard mask}[inverse of subnetmask] area{area number} (0.0.0.0 255.255.255.255 [means any network])
                                            R(config-router)#passive-interface InterfaceName
                                            R(config-router)#passive-interface default      (configure all interfaces to be passive, then exclude some with 'no passive-interface g0/0' command)
                                            R#ip route 0.0.0.0 0.0.0.0 203.0.213.2
                                            R(config-router)#default-information originate  (On the interface connected to the last resort, should be ospf disabled)
                                            R(config-router)#maximum-paths pathsNumber
                                            R(config-router)#distance ADNumber
                                            R(config-router)#auto-cost reference-bandwidth 100000 (reference bandwidth, should be same on all OSPF Rs and greater than the fastest links)
                                        = Per interface:
                                            R(config)#interface g0/0
                                            R(config-if)#ip ospf processID area areaNum         (configure OSPF directly on an interface)
                                            R(config)#router ospf 1(process ID)
                                            R(config-if)#ip ospf cost 10000                     (configure cost on an interface)
                                            R(config-if)#ip ospf priority <0~255>               (configure the DR/BDR election on priority on interfaces within a subnet)
                                        = Displays:
                                            R#show ip protocols 
                                            R#show ip ospf database
                                            R#show ip ospf interface [g0/0]
                                            R#show ip ospf interface brief
                                            R#show ip ospf neighbor
                                            R#clear ip ospf process
                                        NOTEs: 
                                            - Rs with different process IDs can become OSPF neighbors, it is only 'Locally significant'
                                Intermediate System to Intermediate System (IS-IS):
                Exterior Gway Protocol(EGP):
                 Shares routes between different autonomous systems
                    Algorithm:
                        Path vector
                            Types:
                                Border GWay Protocol(BGP)
        S-Static routing: 
         A network engineer/admin manually configures routes on the R. To enable R to send packets to remote Dsts. that are not directly connected to its interfaces
         When the R interface has an “up/up” GUA, the IPv6 prefix and prefix length are added to the IPv6 routing table as a C route Then a L route with a /128.
            Configuration:
                R(config)#ipv6 unicast-routing  [ipv6 routing is disabled by default, however, R will be able to send and receive IPv6 traffic but will not route IPv6 traffic]
                R#ipv6 route destination/prefix-length {next-hop | exit-interface [next-hop]} [ad](for administrative distance)
                    If 'exitInterfaceName' is specified, Proxy ARP will be used 
                R#show ip/ipv6 route    [Output will be in the foramt of "(AD)/(Metric)"]
            Type of Routes:
                Based on node:
                    Network Route:
                        R1(config)#ipv6 route 2001:db8:0:3::/64 2001:db8:0:12::2
                    Host Route:
                        R1(config)#ipv6 route 2001:db8:0:1::100/128 2001:db8:0:12::1
                        R1(config)#ipv6 route 2001:db8:0:3::100/128 2001:db8:0:12::2
                    Default Route:
                        R1(config)#ipv6 route ::/0 2001:db8:0:23::1
                    Floating Routes:
                        By raising the administrative distance higher than the main route, it becomes a backup route. Called floating route.
                Automatic Learned Routes: 
                    192.168.1.0/24, 192.168.1.1/32
                    L-Local: 
                     Routes to the exact IP addresses configured on the R interfaces 
                        = With a /32 in IPv4 or /128 in IPv6. Indicates that all 32b are 'fixed', so it should keep the packets for his own and does not route it
                    C-Connected: 
                     Routes to the network the interfaces are connected to (With the actual netmask configured on the interface)
                Based on configuration:
                    Directly attached:
                        Only the exix interface is specified -> R1(config)#ip route 192.168.1.0 255.255.255.0 g0/0
                        NOTE: 
                            = in IPv6, you CANNOT use directly attached static route if the interface is an Ethernet interface but works if it is a serial interface.
                    Recursive:
                     Requires a recursive lookup in the routing table. R checks its routing table multiple times(1st for Dst., 2nd for next-hop)
                        = Only the next-hop is specified -> R1(config)#ip route 192.168.1.0 255.255.255.0 192.168.2.2
                    Fully specified:
                        = Both the exit interface and the next-hop are specified -> R1(config)#ip route 192.168.1.0 255.255.255.0 g0/0 192.168.2.2
                NOTE: 
                    - 'via Null0' is an interface that discard traffics matches the route.
                    - Routes for LLA are not added to the routing table unless your enter it as a 'fully specified' as the R will not be able to make the recursive lookup.
    Display Commands:
        C:>route print 
        C:>netstat -r. 
        R1#show ip protocol
        R1#show ip route




- Life Of a Packet: 
 Src.IP & Dst.IP never change throughout the whole process, and SWs do not modify anything they just learn the MACs and forward
    PC1(192.168.1.1 1111) sending to PC4(192.168.4.1 1 4444), 
    R1(g0/2 192.168.1.254 aaaa, g0/0 192.168.12.1 bbbb), R2(g0/0 192.168.12.2 cccc, g0/1 192.168.24.2 dddd), R4(g0/1 192.168.24.4 eeee, g0/2 192.168.4.254 fffe) 
    Packet: 
        [S.IP:PC1, Dst.IP:PC2], out of network, so to be sent to DGway
        ARP from PC1 to R1, request BC [S.IP:PC1, Dst.IP:R1g0/2, Dst.MAC:ffff.ffff.ffff.ffff, Src.MAC:PC1] -> reply unicast [S.IP:R10/2, Dst.IP:PC1, Dst.MAC:PC1, Src.MAC:R1g0/2]
        [S.IP:PC1, Dst.IP:PC2, Dst.MAC:R1 g0/2, Src.MAC:PC1], R1 De-encapsulate 3 Layers, find next-hop in routing table, learn next-hop MAC with ARP
        ARP from R1g0/0 to R2g0/0, request BC [S.IP:R1g0/0, Dst.IP:R2g0/0, Dst.MAC:ffff.ffff.ffff.ffff, Src.MAC:R1g0/0] -> reply unicast [S.IP:R2g0/0, Dst.IP:R1g0/0, Dst.MAC:R1g0/0, Src.MAC:R2g0/0]
        [S.IP:PC1, Dst.IP:PC2, Dst.MAC:R2g0/0, Src.MAC:R1g0/0], R2 De-encapsulate 3 Layers, find next-hop in routing table, learn next-hop MAC with ARP, etc......




- Subnetting: 
 Prefix = 1s in the Octet-Binary NID. One of these possible at last Subnet octet [0,128,192,224,240,248,252,254,255]
    [2**x=Number of subnets, x is number of 'borrowed' bits]. Borrowing 1 bit from hosts to networks = can make 2 subnets
    Any PC in each subnetwork, will treat the PCs in another subnet as it is another network and tell the SW to forward it to the R as its DGway
    Before you start subnetting, you should develop an IPv4 addressing scheme for your entire network. You will need to know: 
        - How many subnets you need
        - How many hosts a particular subnet requires
        - What devices are part of the subnet
        - Which parts of your network use private addresses
        - Which use public
    point-to-point network[Only two Rs]: R1 to R2, connecting two cities for example
        Requires only 4 IPs: If class C is used, 252 addresses are wasted
            Network address-> 203.0.113.0/24
            BC address-> 203.0.113.255
            R1 address-> 203.0.113.1
            R2 address-> 203.0.113.2
    CIDR(Classless inter-Domain Routing)[Traditional Within an Octet Boundary]: /32 would result in -1 usable addresses, only used for private host
        i.e. /8 can have 65,536 subnets each capable of connecting 254 hosts if /24 used on it, or 256 subnets with each subnet capable of connecting 65,534 hosts with /16 used
        Wasted address space like above example, and there are many devices being existing every day
        IETF(Internet Engineering  Task Force) in 1993 to replace 'classful' addressing system
        Requirements: CIDR notation examples(/25 2sub, /26 4sub, /27 8sub, /28 16sub, etc.)
            Class A: /8, Class: /16, Class B: /24 were removed
            Allowing larger network to be split into smaller networks(Subnetworks/Subnets)
        Same example above[point-to-point]:
            IP-> 11001011.00000000.01110001[<-Fixed for Network].00000000 = 203.0.113.0/24
            Netmask-> /24 = 255.255.255.0 = 11111111.11111111.11111111[<-Fixed for Network].00000000
            Usable addresses-> 2**8-2 = 254
        New would be[point-to-point]: 
            IP-> 11001011.00000000.01110001.0000000[<-Fixed for Network]0 = 203.0.113.0/31
            Netmask-> /31 = 255.255.255.254 = 11111111.11111111.11111111.1111111[<-Fixed for Network]0
            Host-> 203.0.113.0 ~ 203.0.113.1 = 11001011.00000000.01110001.0000000|0 ~ 11001011.00000000.01110001.0000000|1
            Usable addresses-> 2**2-2 = 0 (But in this case, no need to subtract BC&Network addresses since it is point-to-point, and use the available 2 for the two Rs)
        Quiz: Trick -> Most-right borrowed binary bit in host portion, take its decimal value and double it. And first Subnet is always the original network address.
            - First  Network would have hosts in the range  [0  ~  63] (64 Hosts) -> NID (192.168.1.0/26)   {2**(32-26)-2= 62 Hosts + 2 for BCs&Network = 64}
            - Second Network would have hosts in the range  [64 ~ 127] (64 Hosts) -> NID (192.168.1.64/26)
            - Third  Network would have hosts in the range  [128~ 191] (64 Hosts) -> NID (192.168.1.128/26)
            - Fourth Network would have hosts in the range  [192 ~ 63] (64 Hosts) -> NID (192.168.1.192/26)
        Trick:
            For 192.168.1.0/26 -> 32-26=6 -> 2**6=64(including Network&BC)
            Network|Host 
            128 64  32 16  8  4  2  1
            0.  0. | 0.  0. 0. 0. 0. 0
            Multiply last Network portion Binary(64), and you get next subnet
                0->64->128->192
        Quizs:
            What subnet does host 192.168.5.57/27 belong to?
                1100000000.10101000.00000101.001|11001 = 192.168.5.57
                1100000000.10101000.00000101.001|00000 = 192.168.5.32 Network means 0s in host portion
            Subnet ID: 192.168.5.32/27

            What subnet does host 192.168.29.219/29 belong to?
                1100000000.10101000.00000101.11011|011 = 192.168.29.219
                1100000000.10101000.00000101.11011|000 = 192.168.29.216 Network means 0s in host portion, BC means 1s in host portion
            Subnet ID: 192.168.5.216/29

            You have been given the 172.18.0.0/16 network. Your company requires 250 subnets with the same number of hosts per subnet. What prefix length should you use ?
                Borrowing 8 bits = 256 subnets , 9 hosts bits = 254 hosts per subnet
                172.18.0.0/16 = 10101100.00010010.00000000.00000000 -Becomes-> 172.18.0.0/24 = 10101100.00010010.|11111111[<-New Network portion with the 8 borrowed].00000000
            Subnet ID: /24 (Note that it is okay to reach another class's subnet)

            divide the 172.30.0.0/16 network into subnets of 1000 hosts each. How many subnets are you able to make ?
                10 host bits = 2**10 - 2 = 1022 hosts
                Class B /16, and hosts are 10, that means Network portion is 32-10 = /22 for Network, means 6 borrowed bits = 2**6=64 subnets
    VLSM(Variable-Length subnet masks): From largest to smallest
        All of the above are methods for subnetting using FLSM(Fixed-Length Subnet Masks):
            Means all of the subnets use the same prefix length (ie. subnetting a class C network into 4 subnets using /26)
        Is the process of creating subnets of different sizes, to make your use of network addresses more efficient, more complicated than FLSM.
            - Assign the largets subnet at the start of the address space
            - Assigne the second-largest subnet after it.
            - Repeat the process until all subnets have been assigned.
        Example: Tokyo LAN A [110 hosts], Tokyo LAN B [8 Hosts], Toronto LAN A [29 hosts], Toronto LAN B [45 hosts]. And 192.168.1.0/24 is your network to be subnetted.
            - Tokyo LAN A would be first, Toronto LAN B would be second, Toronto LAN A would be third, Tokyo LAN B would be fourth, point-to-point connection would be the fifth
            
            - Tokyo LAN A needs 110, means 2**7=126, that leaves us with /25 subnetsmask. NID:192.168.1.0/25   | BC.IP:192.168.1.127/25 | firstUsable.IP:192.168.1.1/25   | LastUsable.IP:192.168.1.126/25 | Total usable hosts:124
            - Toronto LAN B needs 45, means 2**6=64, that leaves us with /26 subnetsmask. NID:192.168.1.128/26 | BC.IP:192.168.1.191/26 | firstUsable.IP:192.168.1.129/26 | LastUsable.IP:192.168.1.190/26 | Total usable hosts:62
            - Toronto LAN A needs 29, means 2**5=32, that leaves us with /27 subnetsmask. NID:192.168.1.192/27 | BC.IP:192.168.1.223/27 | firstUsable.IP:192.168.1.193/27 | LastUsable.IP:192.168.1.222/27 | Total usable hosts:30
            - Tokyo LAN B needs 8, means 2**4=16,    that leaves us with /28 subnetsmask. NID:192.168.1.224/28 | BC.IP:192.168.1.239/28 | firstUsable.IP:192.168.1.225/28 | LastUsable.IP:192.168.1.238/28 | Total usable hosts:14
            - Point-to-Point needs 2, means 2**2=4,  that leaves us with /30 subnetsmask. NID:192.168.1.240/30 | BC.IP:192.168.1.243/30 | firstUsable.IP:192.168.1.241/30 | LastUsable.IP:192.168.1.242/30 | Total usable hosts:2




- VLANs(Virtual LANs): 
 on flash, vlan.dat
    LAN:
        Group of devices in a single location, more specificly (a single BC domain, including all devices in that BC domain)
    BC domain: 
     The group of devices which will receive a BC frame (Destination MAC f.f.f.f) sent by any of the members. Rs do not flood BC frames, but they can forward it to another R in a P-2-P network
        Performance: 
            Lots of unnecessary BC (Whether from a host, or a SW does not know the destination and floods the frame) traffic can reduce network performance
        Security: 
            Even within same office, you want to limit who has access to what. PCs within a LAN has direct access to one another without traffic passing through the R.
        Best practice: 
            - Subnetting L3:
                = 3 different interfaces in the R to get connected to each subnet. 
                = But there is still BC in L2 [What if a PC in HR department sent a BC to all HRs], 
                    [Src.IP:PC1, Dst.IP:BC of HR LAN, Src.MAC:PC1, Dst.MAC:F.F.F.F] -> SW only understands L2 addressing, and this means BC to be flooded
            - Buying seprate SWs for each department:
                = But could cost the company, specially small-sized ones.
            - VLANs: 
             Assigning each department to different VLANs, on the SW interface. 
                = Functionality:
                    = SW will not forward traffic between VLANs, including BC/unkown unicast traffic.
                        [Src.IP:PC1, Dst.IP:BC of HR LAN, Src.MAC:PC1, Dst.MAC:F.F.F.F] -> SW will only BC the packet to same VLAN as the sender is member of.
                    = Logically separate end hosts at L2, even if physically connected to same SW,
                    = SW does not perform inter-VLAN routing, it must send the traffic through the R, even if the two PCs are in same subnet but on a different VLAN.
                    = Do not forward traffic directly between hosts in different VLANs
                    = VLANs are configured on SWs on a per-interface basis,
                = Ports:
                    = Access port: 
                     Switchport which belongs to a single VLAN, and usually connects to end hosts like PCs
                    = Trunk ports(Tagged Port): 
                     Swithcports which carry multiple VLANs
                     ISL[Inter-SW Link, created by Cisco and never have to be used now] & IEEE 802.1Q[Standard]
                        = In a small network with few VLANs, we can separate interfaces for each VLAN when connecting SWs to SWs, and SWs to Rs.
                        = In an increased number of VLANs, it will result in wasted interfaces, and often Rs won't have enough interfaces for each VLAN.
                        = Trunk, however, carries multiple VLANs via a single interface
                            SW tags all frames that they send over a trunk link, this allows the receiving SW to know which VLAN the frame belongs to 
                    = Configurations:
                        = Access Port:
                            = VLANs:
                                SW(conf)vlan 10 (Same command to create a VLAN, or access it if exists)
                                SW(conf-vlan)#name TheNameYouWant
                                SW(conf)vlan 20 
                                SW(conf-vlan)#name TheNameYouWant
                            = Per-Port:
                                SW(conf)#interface range f0/1-3
                                SW(conf-if-range)#switchport mode access
                                SW(conf)#interface f0/1
                                SW(conf-if)#switchport access vlan 10
                                SW(conf)#interface f0/2
                                SW(conf-if)#switchport access vlan 20
                        = Trunk Port:
                            = With another SW2/R1:
                                SW(conf)#int g0/0   (to SW2)
                                SW(conf-if)#switchport mode trunk encapsulation dot1q
                                SW(conf-if)#switch mode trunk
                                SW(conf-if)#switchport trunk allowed vlan {10 | all | add/remove 20}
                                SW#show interfaces trunk
                = 802.1Q:
                 The "type" section inside the Ethernet header: 
                    = Length of 4Bytes(32b)
                    = Consists of:
                        - TPID(Tag Protocol Identifier): 
                            = 16b
                            = always sent to a value of 0x8100
                            = indicates that the frame is 802.1Q-tagged
                        - TCI(Tag protocol Information):
                            = PCP(Priority Code Point):
                                = 3b
                                = used for CoS(class of service), to prioritize important traffic in congested networks.
                            = DEI(Drop Eligible Indicator):
                                = 1b
                                = Indicates frames that can be dropped if the network is congested.
                            = VID(VLAN ID):
                                = 12b = 2**12 = 4096 VLANs
                                = range of 0~4096 (1st&Last are reserved, not for use)
                                    = Normal VLANs: 1~1005  (1002~1005 (Reserved for Token ring, FDDI))
                                    = Extended VLANs: 1006~4094
                                = identifies the VLAN the frame belongs to.
                = Types:
                    - Standard VLAN(Management):
                        = which SW can send traffic of same VLANs between SWs in different LANs. 
                        = Takes an IP address 
                        = Configuration:
                            SW(conf)#vlan 99
                            SW(conf)#description mngmt
                            SW(conf)#interface vlan 99
                            SW(conf-if)#ip address 1.1.1.2 255.255.255.0    (configure each R in the way to the DGway with a Vinterface with same vlan 99, change ip address on each)
                            SW(conf)#ip default-gateway 1.1.1.1             (on the R(config)#int f0/0.99 -> R(config-subif)#ip address 1.1.1.1 255.255.255.0)
                    - Native VLAN: 
                     It is VLAN1 by default on all trunk ports, however, can be manually configured on each trunk port
                        = Functionality:
                            = ISL does not have this feature:
                                Read peter Paluch comment-> https://community.cisco.com/t5/switching/why-native-vlan-exists-on-a-trunk/td-p/1363872#:~:text=Basically%2C%20A%20Native%20VLAN%20carries,VLAN%20exists%20on%20a%20trunk
                            = SW does not tag the frames in native VLANs, other SWs receiving untagged frames on trunk port will assume that it belongs to the native VLAN. 
                                = Important that the native VLAN matches between SWs.
                        = Configurations:
                            = With another SW2/R1:
                                SW(conf)#int g0/0   (to SW2)
                                SW(conf-if)#switchport mode trunk encapsulation dot1q
                                SW(conf-if)#switch mode trunk
                                SW(conf-if)#switchport trunk allowed vlan {10 | all | add/remove 20}
                                SW(conf-if)#switchport trunk native vlan 1001 (Important to change native VLAN to an unused VLAN) 
                                SW#show interfaces trunk
                = ROAS(R on a stick):
                 Logical Sub Interfaces
                    = Functionality:
                        = to divide one interface on a R, to route between multiple VLANs using a single interface on the R and SW on same physical connection in trunk ports
                        = SW interface is configured as a regular trunk, R interface is configured using subinterfaces and you configure the VLAN tag and IP address on each subinterface
                    = Configurations:
                        = Trunking with ROAS:
                            R1(conf)#int g0/0
                            R1(conf-if)#no shutdown
                            R1(conf-if)#int g0/0.10
                            R1(conf-subif)#encapsulation dot1q 10
                            R1(conf-subif)#ip address 192.168.1.62 255.255.255.192
                            R1(conf-if)#int g0/0.20
                            R1(conf-subif)#encapsulation dot1q 20
                            R1(conf-subif)#ip address 192.168.1.126 255.255.255.192
                            R1(conf-if)#int g0/0.30
                            R1(conf-subif)#encapsulation dot1q 30
                            R1(conf-subif)#ip address 192.168.1.190 255.255.255.192
                        = Native VLANs with ROAS:
                            R1(conf-if)#int g0/0.10
                            R1(conf-subif)#encapsulation dot1q 10 native
                                OR  (Configure the IP for the native VLAN on the R's physical interface)
                            R1(conf-if)#no int g0/0.10
                            R1(conf-if)#int g0/0
                            R1(conf-if)#ip address NativeVLANiPaddress NativeVLANsubnetMask"
                = Multiple layer SW(L3 SW): 
                 Capable of both Switching & Routing. It is L3 aware.
                    = Functionality:
                        = IP addresses can be assigned to interfaces like a R. 
                        = Can create virtual interfaces for each VLAN.
                        = Can configure routes on it like a R. 
                        = Can be used for inter-VLAN routing.
                    = Trunking: 
                     Trunk link will be replaced by a L3 point-to-point connection: 
                        = SVIs(SW virtual interfaces): 
                            = Sending traffic to different subnets/VLANs with the L3 SW
                            = virtual interfaces you can assign IP addresses to in a multilayer SW. 
                            = Host connected to the SW must already have the DGway address configured on their host OS.
                            = Configure each PC to use the SVI(NOT the R) as their DGway, and the L3 SW will have the R as its Default Route
                    = Configurations:
                        = On the R:
                            R(conf)#no int g0/0.10, g0/0.20, g0/0.30
                            R(conf)#default interface g0/0   (to SW2)
                            R(conf)#int g0/0
                            R(conf-if)#ip address 192.168.1.194 255.255.255.252  (The point-to-point connection with the L3 SW)
                        = On the L3 SW:
                            SW(config)#default interface g0/1 (to R1)
                            SW(config-if)#ip routing    (to enable L3 routing)
                            SW(config-if)#no switchport (becomes routed port)
                            SW(config-if)#ip address 192.168.1.193 255.255.255.252
                            SW(config-if)#exit
                            SW(config)#ip route 0.0.0.0 0.0.0.0 192.168.1.194   (default route, last resort)
                            SW#show interfaces status
                            = Vinterface:
                                SW(config)#interface vlan10 -> SW(config-if)#ip address 192.168.1.62 255.255.255.192  -> SW(config-if)#no shutdown
                                SW(config)#interface vlan20 -> SW(config-if)#ip address 192.168.1.126 255.255.255.192 -> SW(config-if)#no shutdown
                                SW(config)#interface vlan30 -> SW(config-if)#ip address 192.168.1.190 255.255.255.192 -> SW(config-if)#no shutdown
                = Displays:
                    SW#show interfaces trunk
                    SW#show interface f0/3 switchport   (shows operational mode)
                    SW#show vlan brief                  (shows the access ports(untagged) assigned to each VLAN)
                    NOTE:
                        = By default all interfaces are under VLAN1 [VLANs 1,1002~1005 exist by default and cannot be deleted]




- DTP(Dynamic Trunking Protocol)/VTP(VLAN trunking protocol):
    DTP: Proprietary protocol that allows two cisco SWs only to dynamically negotiate their interface status(Access/Trunk). Two SWs can form a trunk, otherwise, with any other device automatically will be an access port
        Enabled by default on all cisco SWs interfaces.
        DTP should be disabled on all interfaces, manual configuration is recommended
        Configuration: "show interfaces g0/0 switchport"-> operational modes(trunk/static access[accessPort belongs to a single VLAN that does not change]/dynamic access[server automatically assign the VLAN depending on the MAC address of the connected device])
            "switch mode dynamic desirable"[actively trying to form a trunk with other cisco switches. will form it if connected to a switchport in the modes trunk/dynamic desirable/dynamic auto]
            "switch mode dynamic auto"[NOT actively trying to form a trunk with other cisco switches. will form it if connected to a switchport in the modes trunk/dynamic desirable]
            "switch mode trunk" AND "switch mode access"[causes a mismatch, and results in error]

            Admin.Mode| Trunk |  Dy.Des |  Access |  Dy.Auto
            -------------------------------------------------
            Trunk     | Trunk |  Trunk  |    X    |   Trunk
            -------------------------------------------------
            Dy.Des    | Trunk |  Trunk  | Access  |   Trunk
            -------------------------------------------------
            Access    |   X   |  Access | Access  |   Access
            -------------------------------------------------
            Dy.Auto   | Trunk |  Trunk  | Access  |   Access

        Disable: "switchport nonegotiate"
        ISL&dot1q: If SWs have both, they will levarage DTP to negotiate the trunk encpasulation mode. "switchport trunk encapsulation negotiate". ISL is favored however. 
            DTP frames: will be sent in VLAN1 in ISL, and in Native VLAN (Which is VLAN1) in dot1q 
    VTP: "show vtp status"
        Allows you to configure VLANs on a central VTP server SW, and other SWs(VTP Client) will synchronize their LAN database to the server
        Desined for large networks with many LANs, so you DRY for each SW configuration
        Recommended not to use.
        Versions: 1,2, and 3. "vtp version 3"
        Modes: "vtp domain GREF", if a SW with no VTP domain(null) receives a VTP advertisement with a VTP domain name, will automatically join it. And if already in a domain but received an Ad. with higher revision number it will its VTP DB to match.
            Server(Default for CISCO SW), "vtp mode server"
                Can add/delete/modify VLANs
                Store VLANs DB in NVRAM
                Increasaes the revision number everytime a VLAN added/Deleted/Modified
                Advertise latest version of VLAN DB on a trunk interfaces, then VTP Clients synchronize their DB to it.
                VTP Servers also function as VTP CLient, means they synchronize their DB to a higher VTP server in revision number.
            client,   "vtp mode client"
                Cannot add/delete/modify VLANs
                Does not Store VLANs DB in NVRAM
                synchronize their DB to the server with the heighest revision number in their VTP domain.
            transparent. "vtp mode transparent"-> resets revision number to 0
                Does not participate in the VTP domain(Does not sync its VLAN DB)
                Maintain DB in NVRAM, can add/delete/modify but won't advertise to other SWs
                Will forward VTP Ad. that are in the same domain as it.




- STP(Spanning Tree Protocol): 
 Layer 2. Bridge here means SW. Works at all vendors' SWs.
    Network Redundancy: 
        Net. is expected to run 24/7/365, short downtime can be disastrous for a business
        If a component fails, you Must ensure other components will take over with little or no downtime
        NIC: 
            PCs only have a single network interface card, so they can only be plugged into a single SW
        BC storms: 
            BC loop at L2 with no TTL(only L3)
            MAC address flapping: 
                as BC stroms arrive at each interface of a SW, it will continue to updating its MAC table with the new interface name associating it to the Src.MAC received

    Prevents L2 loops: 
        By placing redundant ports in a {blocking state}, essentially disabling the interface
        By selecting which ports are {forwarding} and which ports are {blocking}, STP creates a single path to/from each point in the network.

    Versions:
        Industry Standards(IEEE):
            Spanning Tree Protocol 802.1D: 
                The original STP
                All VLANs share one STP instance, cannot load balance
            Rapid Spanning Tree Protoco(802.1W):
                Much faster at converging/adapting to network changes than 802.1D
                All VLANs share one STP instance, cannot load balance
            Multiple Spanning Tree Protocol(802.1s):
                Uses modified RSTP mechanics
                Can group multiple VLANs into different instances(ie. VLANs 1-5 in instance 1, VLANs 6-10 in instance 2) to perform load balancing
        Cisco Versions:
            Per-VLAN Spanning Tree Plus(PVST+):
                updagrade to 802.1D
                Each VLAN has its own STP instance
                Can load balance by blocking different ports in each VLAN
            Rapid Per-VLAN Spanning Tree Plus(Rapid PVST+)
                Upgrade to 802.1W
                Each VLAN has its own STP instance
                Can load balance by blocking different ports in each VLAN
    - STP mode:
        "SW(config)#spanning-tree mode mst/pvst/rapid-pvst"
        - Classic Spanning Tree Protocol ieee 802.1D: 
            Each [non-rootBridge] SW will have ONE of its interfaces to be its [rootPort](lowest rootCost) to act in {forwarding state} to not block [rootBridge] signals. 
            -Interfaces States:
                - (R)/(D)   ports remain stable in a {Forwarding} state. 
                - (N)       port  remain stable in a {Blocking}   state.
                - (LSN)/(LRN) ports are Transitional states, which are passed through when an interface is activated, or when a {Blocking} port must transition to a {Forwarding} due to a failure in the topology.
                - (Disabled) Administritavely
                - {Blocking stated}(N)(altr): Stable
                    - (N) ports are in {Blocking} state
                    - Effectively disabled to prevent loops
                    - Do not 'send/receive' regular traffic
                    - Keeps receiving STP-BPDU(Bridge/SW Protocol Data Units) [To keep up-to-date with the network topology]
                    - Do not forward STP-BPDU
                    - Do not learn MAC address, and drops traffic Immediately.
                    - Act as backups that can enter a {forwarding state} if an active(currently forwarding) interface fails
                    - Every collision domain(each link) has a single STP (D) port.
                    Choosing criteria:
                        1- SW with lowest [rootCost] will make its port (D)
                        2- If [rootCost] is same, SW with [Lowest BridgeID] will make its port (D)
                        3- The other SW will make its port [non-D](N)(altr)
                - {Listening}(LSN): Transitional
                    - After the {Blocking} state, (D)/(R) ports enter the {Listening} state. (N) ports are always {Blocking}.
                    - {Listening} state is 15Sec long by default, determined by the [Forward Delay] timer.
                    - ONLY 'forward/receive' STP-BPDU
                    - Do not 'send/receive' regular traffic
                    - Do not learn MAC addresses from regular traffic. 
                - {Learning}(LRN): Transitional 
                    - After the [Listening] state, (D)/(R) ports enter the {Learning} state.
                    - {Learning} state is 15Sec long by default, determined by the [Forward Delay] timer(Same is used for both {Listening}&{Learning}. Means, it takes total of 30Sec to move from both states and enter the {Forwarding})
                    - ONLY 'sends/receive' STEP-BPDU
                    - Do not 'send/receive' regular traffic
                    - LEARNS MAC addresses from regular traffic.
                - {Forwarding stated}: Stable
                    All interfaces to PCs are always forwarding.
                    - (R)/(D) ports are in {Forwarding} state
                    - Operate as normal
                    - 'Send/Receive' normal traffic
                    - LEARNS MAC addresses
                - {Disabled}(Ds): Administritavely disabled -> Shutdown ports
                Summary table:
                STP Port State        Send/Receive BPDUs        Regular Traffic        MAC Learning        Stable/Transitional
                Blocking                   NO/YES                     NO                   NO                    Stable
                --------------------------------------------------------------------------------------------------------------
                Listening                 YES/YES                     NO                   NO                    Transitional
                --------------------------------------------------------------------------------------------------------------
                Learning                  YES/YES                     NO                  YES                    Transitional
                --------------------------------------------------------------------------------------------------------------
                Forwarding                YES/YES                    YES                  YES                    Stable
                --------------------------------------------------------------------------------------------------------------
                Disabled                    NO/NO                     NO                   NO                    Stable
                --------------------------------------------------------------------------------------------------------------
            - STP-Timers:
                Hello:
                    How often the [rootBridge] sends hello BPDUs [every 2Sec]. Other SWs do no generate their own 'Hello BPDUs', they only forward the [rootBridge's] out of their (D) ports [Not out of (N)/(R)]
                Forward Delay:
                    How long the SW will stay in the {Listening} & {Learning} states [30Sec, 15Sec each]
                Max Age: 
                    How long an interface will wait [after ceasing to receve 'Hello BPDUs] on one interface [i.e. (N)] to change the STP topology. [20Sec, 10*Hello(2Sec)]
                    count down 20 19 then receives a 'Hello BPDU', resets to 20 19 again. If no 'Hello BDPUs' received, will count all the way to 0
                        - SW will reevaluate its STP choices, including [rootBridge], and local root, (D), and (N) ports
                        - If (N) port is selected to become a (D) or [rootPort], it will transition from {Blocking} to {Listening} 15Sec, {Learning} 15Sec, and finally {Forward}. So, up to 50Sec for a {Blocking} to transit to {Forwarding} 
                    NOTE: A {Forwarding} can directly move to {Blocking} state, as no worry about creating loop. However, a {Blocking} must go through transitioning states to not accidentally create loops. 
            - Ethernet Dst.MAC: PVST+(Supports 802.1Q)->(01:00:0c:cc:cc:cd) [Regular STP(not PVST), uses a Dst.MAC->(0180.c200.0000)]
            - STP-BPDU:
                Protocol Identifier: STP 0x0000
                Protocol Version Identifier: ST 0
                BPDU Type: COnfiguration 0x00
                BPDU flags: 0x00 [singal topology changes]
                    topology Change acknowledgment: No
                    topology Change: No
                Root Identifier: 
                    BridgePriority
                    SysExID
                    SysID/MAC
                Root Path Cost: 0 [rootBridge]
                Bridge Identifier:
                    BridgePriority
                    SysExID
                    SysID/MAC
                Port Identifier: 0x8002 [0x80=128]
                Message Age: 0 [0 from [rootBridge], increases each time passes by a SW, till it goes to final SW's MaxAge and reduce it with the total value collected. i.e. 20-5=15]
                Max Age: 20         [STP 3 timers on the [rootBridge] determine the STP timers for the entire network]
                Hello Time: 2       [STP 3 timers on the [rootBridge] determine the STP timers for the entire network]
                Forward Delay: 15   [STP 3 timers on the [rootBridge] determine the STP timers for the entire network]
                Optional Features (STP-Toolkit):
                    Portfast: Enabled on (D) ports connected to PCs, because no risk of forming a loop, no need to wait for 30Sec. Bypassing {Listening}&{Learning}
                        "SW(config)#interface g0/2" -> "SW(config-if)#spanning-tree portfast" OR "SW(config)#spanning-tree portfast default" [should be access ports]
                    BPDU Guard:
                        If enabled and receives a BPDU from another SW, the interface will be shutdown to prevent a loop from forming.
                        "SW(config)#interface g0/2" -> "SW(config-if)#spanning-tree bpduguard enable" OR "SW(config)#spanning-tree bpduguard default" [takes effect on Portfast-enabled interfaces]
                    Root Guard: Even if the interface received a superior BPDU(Lower BridgeID), SW will not accept the new SW as the [rootBridge]. The interface will be disabled.
                    Loop Guard: Even if the interface stops receiving BPDUs, it will not start {Forwarding}. The interface will be disabled.
            - STP-enabled SWs: 
                Send/Receive "Hello BPDU" out of all interfaces, the default timer is 2Sec(out of every interface, once every 2Sec)
                If a SW receives a "Hello BPDU on an interface" it knows that interface is connected to another SW(R, PCs, etc. do not use STP).
                Hello BPDU:
                    SWs use one field in the STP BPDU, the "BridgeID" field, to elect a [rootBridge] for the network
                    The SW with the lowest "BridgeID" becomes the [rootBridge]
                    All ports on the [rootBridge] are {designated port}(D) put in a {forwarding state}, and other SWs in the topology must have a 'path' to reach the [rootBridge]

                    "BridgeID": 
                        - BridgePriority(16b): Most-significant bit is set by Default to 1(32768) on all SWs.
                            - Updated BridgePriority: 
                                - BridgePriority(BP)(4b): 32768   16384   8192   4096
                                                            1       0       0      0
                                - ExtendedSystemID(ESID)/VLANID(12b): 2048   1024   512   256   128   64   32   16   8   4   2   1
                                                                        0      0     0     0     0     0    0    0   0   0   0   1
                                    Cisco SWs uses an PVST(Per-VLAN Spanning Tree)[only ISL trunk encapsulation], runs a separate STP 'instance' in each VLAN, so in each VLAN different interfaces can be forwarding/blocking. Means one interface could be forwarding one VLAN but blocking another.
                                Total = 32768+1 in the case of VLAN 1, etc.
                                Changing:
                                    Keep in mind the extendedSystemID is set and cannot be changed as it is determined by the VLAN ID. 
                                    Total bridge priority(BP+ESID) in units of 4096(Least-significant bit of BP) increament up to 61440. 4096 is the value of the least significant bit of the bridge priority. So for each VLAN you can have different SW as its [rootBridge]
                        - MAC Address(48b): Used as the tie-breaker [Lowest MAC address becomes the [rootBridge]. A lower than B]
                        NOTE: 'BridgePriority' is compared first, if they tie on both ends, the MAC address is then compared
            - [rootBridge]:
                When any SW is powered on, it assumes it is the [rootBridge]. Will only give up its position if it receives a 'superior' BPDU(Lower "BridgeID")
                Once all SWs agreed on the [rootBridge], only the [rootBridge] sends BPDUs. Other SWs in the network will forward these PBDUs, but will not generate their own original BPDUs.
                All interfaces on the [rootBridge] are {designated ports}, in a {forwarding state}.
                Load Balancing: Configure different [rootBridge] on different VLANs, to not waste ports being same state at all VLANs.

                    - Except for [rootBridge], all interface will be [rootPort].
                        [rootPort](R): 
                            Way of determining the path to [rootBridge] by electing the lowest [rootCost] on one of its interfaces. 
                            If all interfaces rootCost are same, then we choose the interface connected to the [Lowest neighbor BridgeID], if same then we choose the connected [Lowest neighbor STP-portID]
                                STP-portID= Prio.Nbr in SW1#"show spanning-tree" -> port-priority(default 128) + port-number. i.e. G0/2 to neighbor G0/1 be (R), not G0/0 to neighbor G0/2. Focus, lowest neighbor STP-portID not its lowest STP-portID
                            [rootCost](rootPathCost)[RPC]: [The lowest cost calculating till reaching [rootBridge]](SW adds their rootCost to each incoming BPDU RPC)
                                Interfaces Speed:   10Mbps   100Mbps     1Gbps       10Gbps [The faster speed, the lower cost]
                                [STP Cost]:           100       19         4            2   
                                Determined with the total [STP Cost] of only the {outgoing} interfaces[has no (D) connected to it] along the path to the [rootBridge].
                                Calculated by a SW interface [STP Cost] + receiving [STP Cost] Ad on that interface. However, On the [rootBridge], all interfaces [rootCost] are 0 so they all are [rootPorts]
                                i.e.-> 
                                    SW2: Pri:12289, MAC:193D.72DE.36E1, G0/0[to SW4]&G0/1[to SW1]
                                    SW1: Pri:32769, MAC:014A.38F1.BA81, G0/0[to SW2]&G0/1[to SW3]
                                    SW3: Pri:32769, MAC:014A.3821.2981, G0/0[to SW1]&G0/1[to SW4]
                                    SW4: Pri:32769, MAC:83F1.2846.392F, G0/0[to SW3]&G0/1[to SW2]
                                    1- SW2's Pri is the lowest, hence, he is the [rootBridge]. G0/0&G0/1 are (D)
                                    2- SW1's G0/0 has total [rootCost] of 4 with SW2's G0/1, hence, SW1's G0/0 is (R) AND SW2's G0/1 is (D)
                                    3- SW4's G0/1 has total [rootCost] of 4 with SW2's G0/0, hence, SW4's G0/1 is (R) AND SW2's G0/0 is (D)
                                    4- SW3's G0/0 has total [rootCost] of 8 with SW1's G0/1& 
                                        SW3's G0/1 has total [rootCost] of 8 with SW4's G0/0, hence, SW3's G0/0 is (R) AND SW1's G0/1 is (D). [SW1's MAC is lower than SW4's].
                                    NOTE: SW3's G0/1 to SW4's G0/0 has no (D) or (R). Hence, SW3's G0/1 is (D) AND SW4's G0/0 is (N)(altr) as a backup. [rootCost same, Pri same, SW3's MAC is lower]
                            The ports connected to another SW's [rootPort]{Forwarding}[R] MUST be designated{Forwarding}[D]. Link with no (D) or (R), will be blocked as a backup.
            Summary of classic-STP:
                1) One SW is elected as the [rootBridge] All its ports are (D){Forwarding}. Choosing criteria: 
                    1: Lowest [BridgeID]
                2) Each remaining SW will select ONE of its interfaces to be its (R){Forwarding}. Ports across from the (R) are always (D). Choosing criteria:
                    1: Lowest [rootCost]
                    2: Lowest [neighbor BridgeID]
                    3: Lowest [neighbor portID]
                3) Each remaining collision domain will select ONE interface to be (D){Forwarding}. The other port in the collision domain will be (N)(altr){Blocking}. Choosing criteria:
                    1: Interface on the SW with lowest [rootCost] will be (D) 
                    2: Interface on the SW with lowest [BridgeID] will be (D)
                    3: The other SW will make its port [non-D](N)(altr)
        - Rapid Spanning Tree(RST):
            Not a timer-based ST algorithm like 208.1D. The heart of the protocol, is a new bridge-bridge handshake mechanism, which allows ports to move directly to forwarding.
            - Elects a [rootBridge] same as STP
            - Elects a [rootPort] same as STP
            - Elects a (D) same as STP.
            - [rootCost](rootPathCost)[RPC]:
                Interfaces Speed:   10Mbps   100Mbps     1Gbps       10Gbps       100Gbps       1Tbps       10Tbps
                [STP Cost]:       2,000,000  200,000     20,000       2000          200          20           2
            - Interfaces States:
                {Discarding} = {Blocking}+{Disabled}: 
                    If a port is administratively disabled(shutdown)
                    If a port is enabled but blocking traffic to prevent a L2 loops
                    {Listening}: Not used
            - Port Roles:
                (R): Same as STP
                (D): Same as STP
                (N): Became 
                    Alternate port(A):
                        Dicarding port that receives a superior BPDU from another SW. [Same as (N) in STP]
                        Function as a backup to the (R) on same SW. [If (R) fails, SW immediately move its best (A) port to {Forwarding}] [Similar to UplinkFast in STP]
                    Backup Port(Bck):
                        Discarding port that receives a superior BPDU from another interface on the same SW. [Happends when 2 interfaces are connected to same collision domain(via a hub)]
                        Interface with the lowers port ID will be selected as the (D), the other will be (B)
            - STP-BPDU:
                Protocol Identifier: STP 0x0000
                Protocol Version Identifier: RST 2
                BPDU Type: Rapid/Multiple ST 0x02
                BPDU flags: 0x3c, Forwarding, Learning, Port Role: Designated
                    topology Change acknowledgment: No
                    Agreement: No
                    Forwarding: Yes
                    Learning: Yes
                    Port Role: (D) 3
                    Proposal: No
                    topology Change: No
                Root Identifier: 
                    BridgePriority
                    SysExID
                    SysID/MAC
                Root Path Cost: 4
                Bridge Identifier:
                    BridgePriority
                    SysExID
                    SysID/MAC
                Port Identifier: 0x8001 [0x80=128]
                Message Age: 1 
                Max Age: 20
                Hello TIme: 2
                Forward Delay: 15
                Version 1 Length: 0
            - Features:
                BackboneFast: 
                    Allows SW to rapidly expire the max age timers on its interface and forwards the superior BPDUs to the other SW that been cut-off from the [rootBridge] to stop assuming it is the [rootBridge].
                [rootBridge]:
                    All SW other than the [rootBridge] sends their own BPDUs.
                    A SW consider a neighbor lost if it misses 3 BPDUs(6Sec) [not 10 as in STP]. It will then 'flush' all MAC addresses learned on that interface
            - Link Types:
                Edge(like STP PortFast): A port that is connected to an end host. Moves directly to {Forwarding}, without negotiation.
                    SW1(config-if)# spanning-tree portfast
                Point-to-Point: A direct connection between 2 SWs
                    Full-Duplex
                    SW1(config-if)# spanning-tree link-type point-to-point
                Shared: A connectoin to a hub. Must operate in half-duplex mode to avoid collisions.
                    Half-Duplex
                        SW1(config-if)# spanning-tree link-type shared

    Commands:
        SW#"show spanning-tree detail/summary {vlan number}" [detail shows the total [rootCost], other will show just the local interface [rootCost]]
        SW(config)#"spanning-tree vlan 1 root primary" -> SW(config)#"do show spanning-tree" [Manipulating to force a specific SW to be the [rootBridge]] (sets BridgePriority to 24576, and if another SW has lower than this number, it reduces itself to 4096)
        SW(config)#"spanning-tree vlan 1 root secondary" (sets BridgePriority to 28672()
        SW(config-if)#"spanning-tree vlan 1 cost/port-priority"




- EtherChannel(Port Channel/Link Aggregation Group(LAG)):
 Allows to gather multiple physical interfaces to operate as one single logical interface. Either at L2 or L3.
    SWs names based on layers:
        Access SW(ASW): Access Layer SW, end hosts connect to
        Distribution SW(DSW): Distribution Layer SW, access layer SWs connect to
    Oversubscription: When the bandwidth of an interface connected to end hosts is > bandwidth connected of the connection to DSWs.
    Solutions:
        - Adding many links between ASW to DSW for congestion that ASW's hosts will create, all links excep one will be disabled by STP.
        - Etherchannel:
         Represented by drowing a circle around a group of links, as a single logical interface. STP will treat this group as a single interface.
         Traffic using the EtherChannel will be load balanced among the physical interfaces in the group. An algorithim is used to determine which traffic will use which physical interface.
         The bandwidth of the logical interface will equal all the interfaces' bandwidths combined. 
         UP to 8 interface can be formed (LACP allows up to 16, but puts 8 in standby mode waiting for an active interface to fail)
            - Flow:
             A communication between 2 nodes in a network. (PC1-to-SRV1 is a flow, PC1-to-PR1 is another separate flow)
             Once one of the interfaces in the group is chosen by the 1st frame in a flow, the rest set of the frames for this flow will use same physical interface.
             If frames in the same flow were forwarded using different physical interfaces, some frames may arrive at the Dst. out of order, which can cause problems.
                Calculation to determine:
                    Src.MAC, OR Dst.MAC, OR Src.&Dst.MAC, OR Src.IP, OR Dst.IP, OR Src.&Dst.IP, OR TCP/UDP port numbers
                    Conf:
                        ASW1(config)#port-channel load-balance src-dst-mac  [Load-balance method]
            - Methods:
                Port Aggregation Protocol(PAgP):
                    Cisco Proprietary protocol, Dynamically negotiates the creation/maintenance of the EtherChannel [Like DTP does for trunks]
                    Conf:
                        ASW1(config)#interface range g0/0-3 -> ASW1(config-if-range)#channel-protocol pagp -> ASW1(config-if-range)#channel-group 1 mode desirable/auto
                            auto+auto=              NO EtherChannel
                            desirable+auto=         EtherChannel
                            desirable+desirable=    EtherChannel
                        NOTE: channel-group number has to match for member interfaces on a same SW, however it does not have to on the other SW.
                Link Aggregation Control Protocol(LACP):
                    IEEE 802.3ad, Dynamically negotiates the creation/maintenance of the EtherChannel [Like DTP does for trunks]
                    Conf:
                        ASW1(config)#interface range g0/0-3 -> ASW1(config)#channel-protocol lacp -> ASW1(config)#channel-group 1 mode active/passive
                            passive+passive= NO EtherChannel
                            active+passive=  EtherChannel
                            active+active=   EtherChannel
                Static EtherChannel:
                    A protocol isn't used to determine if an EtherChannel should be formed, instead interfaces are statically configured to form an EtherChannel
                    Conf:
                        ASW1(config)#interface range g0/0-3 -> ASW1(config)#channel-group 1 mode on
                        NOTE: "on mode" only works with "on mode" on the other SW. [on + desirable OR on + active will not work]
            - Member interfaces must match:
                Same duplex(full/half)
                Same speed
                Same Switchport mode (access/trunk)
                    If trunk, same allowed VLANs/native VLAN
                NOTE: If an interface's configurations changed and do not match the others, it will be suspended/excluded from the EtherChannel.
            - Configuration:
                L2 SW:
                    ASW1(config)#interface range g0/0-3 -> ASW1(config-if-range)#channel-protocol lacp/pagp -> ASW1(config-if-range)#channel-group 1 mode active/passive/on
                    ASW1(config)#interface port-channel 1 -> ASW1(config-if)#switchport trunk encapsulation dot1q -> ASW1(config-if)#switchport mode trunk
                L3 SW:
                    ASW1(config)#interface range g0/0-3 -> ASW1(config-if-range)#channel-protocol lacp/pagp -> ASW1(config-if-range)#channel-group 1 mode active/passive/on
                    ASW1(config-if-range)#no switchport -> ASW1(config)#interface po1 -> ASW1(config-if)#ip address xxx.xxx.xxx.xxx xxx.xxx.xxx.xxx -> 
                    ASW1(config)#interface port-channel 1 -> ASW1(config-if)#switchport trunk encapsulation dot1q -> ASW1(config-if)#switchport mode trunk
                Displays:
                    ASW1#show interface trunk
                    ASW1#show spanning-tree
                    ASW1#show cdp neighbors [cisco discovery protocol, shows interfaces information]
                    ASW1#show etherchannel summary/port-channel
                    ASW1#show interface port-channel 1
                    ASW1#show etherchannel load-balance




- IPv6: 
 (HEX Group seprated by colon[quartets])8*4(HEX values), each HEX in the 4 has 4b, (HEX)4*4(Bits)=16b(hextet) in each group, (HEX)4*8(Grps)=32 total HEXs. 2**128(16b*8grps) 
 Addressing Possibilities (340 undecillion, 36 zeros)

    Prefix Length: 
     range from 0 to 128, recommended for LAN /64. prefix is 64b leaving another 64b for the Interface ID (host portion)
     Typically, an enterprise requesting IPv6 addresses from their ISP will receive a /48 block.
     Typically, IPv6 subnets use a /64 prefix length. Therefore, an enterprise has 16 bits to use to make subnets
     ie. GUI:   2001:0DB8:8B00:{48b 'global routing prefix'}:0001{16b 'subnet identifier'}:0000:0000:0000:0001{64b 'interface identifier', the host portion}
                {                   The 64b network portion               {65000 subnets}}{                     The 64b host portion                       }
        Finding the IPv6 prefix:
         Convert the right half all zeros
            Multiple of fours:
                300D{16th}:00F2{32nd}:0B34{48th}:2{52nd}1{56th}00{64th}:0000{80th}:0000{96th}:1200{112th}:0001{128th}/56 -> 
                300D{16th}:00F2{32nd}:0B34{48th}:2{52nd}1{56th} ->
                300D{16th}:00F2{32nd}:0B34{48th}:2{52nd}1{56th}00::/56 ->
                300D:00F2:0B34:2100::/56 -> 300D:F2:B34:2100::/56
            Non-Multiple of fours:
                2001{16th}:0DB8{32nd}:8B00{48th}:0001{64th}:FB89{80th}:0{84th}1{88th}7{92nd}B{96th}:0020{0b112}:0011{0b128}/93 -> 
                2001{16th}:0DB8{32nd}:8B00{48th}:0001{64th}:FB89{80th}:0{84th}1{88th}7{92nd}B{96th}::/93 ->   [Zeroing right portion of hosts]
                2001{16th}:0DB8{32nd}:8B00{48th}:0001{64th}:FB89{80th}:0{84th}1{88th}7{92nd}B{0d11}::/93 ->   [converting the Hex 'B' to 4 dicimal digits, which are combine {0b96} in the IPv6]
                2001{16th}:0DB8{32nd}:8B00{48th}:0001{64th}:FB89{80th}:0{84th}1{88th}7{92nd}B{0b1011}::/93 -> [Converting the dicimal into binary]
                2001{16th}:0DB8{32nd}:8B00{48th}:0001{64th}:FB89{80th}:0{84th}1{88th}7{92nd}B{0b1000}::/93 -> [zeroing right portion of hosts, which are the right 3 bit of the 'B']
                2001{16th}:0DB8{32nd}:8B00{48th}:0001{64th}:FB89{80th}:0{84th}1{88th}7{92nd}B{0d8}::/93 ->    [Converting the binary to decimal]
                2001{16th}:0DB8{32nd}:8B00{48th}:0001{64th}:FB89{80th}:0{84th}1{88th}7{92nd}B{0x8}::/93 ->    [Converting the decimal to Hex]
                2001{16th}:0DB8{32nd}:8B00{48th}:0001{64th}:FB89{80th}:0{84th}1{88th}7{92nd}8{0x8}::/93 ->    [Replacing 'B', with only its first bit as 1s and other 3 as 0s, results in Hex '8']    
                2001:0DB8:8B00:0001:FB89:0178::/93 -> 2001:DB8:8B00:1:FB89:178::/93
            EUI-64(Extended Unique ID, Modified EUI-64)
             A method of converting a MAC address(48b) into a 64b interface identifier. This interface identifier can then become the 'host portion' of a /64 IPv6 address.
                Represented in binary and is made up of three parts:
                    - 24b MAC OUI, but the 7th bit LTR (U/L bit) is reversed. Means if it is a 0, it becomes a 1, and vice versa.
                    - The inserted 16b value FFFE (in Hex) in the middle of MAC.
                    - 24b MAC Device Identifier from the client MAC address. 
                        Then combining every 4b into HEX, and combine every 2Hex as a group,
                        If you add FE80:: at the left beggining, you get a link-local
                        %4-> Each interface on my PC will have an interfaceID as a percentage to reduce load when communicating and specify how to reach the Dst.host easier
                Functionality:
                    - Divide the MAC in half:
                        1234 56 | 78 90AB
                    - Inser FFFE in the middle:
                        1234 56FF | FE78 90AB
                    - Invert the 7th bit:
                        12(8th)34 56FF FE78 90AB
                        12(0d2)34 56FF FE78 90AB    [Converting Hex to decimal]
                        12(0b0010)34 56FF FE78 90AB [Converting decimal to binary]
                        12(0b0000)34 56FF FE78 90AB [Converting the 7th]
                        12(0d0)34 56FF FE78 90AB    [Converting binary to decimal]
                        12(0x0)34 56FF FE78 90AB    [Converting decimal to Hex]
                        10(0x0)34 56FF FE78 90AB    [Replacing the '2' Hex with '0' Hex of 0000 binary]
                        1034 56FF FE78 90AB         [This is the interface identifier]
                     Why:
                        MAC address divided into two types:
                            Universally Administered Address(UAA): Uniquely assigned to the device by the manufacturer
                            Locally Administered Address(LAA):     Manually assigned by an admin(ie. 'mac-address command) or protocol. Does not have to be globally unique
                        Identifying UAA/LAA by the 7th bit of the MAC, called the U/L bit:
                            U/L bit set to 0 = UAA
                            U/L bit set to 1 = LAA
                        Reversing the U/L bit in EUI-64:
                            U/L bit set to 0 = The MAC the EUI-64 interface ID was made from was an LAA
                            U/L bit set to 1 = The MAC the EUI-64 interface ID was made from was an UAA

    Appreviation: 2001:0000:0000:012c:0000:0000:0000:010d
        According to RFC 5952: 
            Leading 0s MUST be be removed, 
            :: MUST be used to shorten the longest string of all-0 quartets, 
            if there are two equal-length choices for the ::, use :: to shorten the one on the left,
            HEX characters MUST be written using lower-case, NOT upper-case A B C D E F
        - Omit Leading Zeros: any zero on left, no need to be typed
            This->    2001 : 0db8 : 0000 : 1111 : 0000 : 0000 : 0000 : 0200
            Becomes-> 2001 :  db8 :    0 : 1111 :    0 :    0 :    0 :  200
        - Double Colon Zero copression: contiguous string of one or more 16-bit hextets consisting of all zeros, replaced by (::), one time only
            This->    2001:db8:cafe:1:0:0:0:1 (leading 0s omitted) 
            Becomes-> 2001:db8:cafe:1::1
            NOTE: 2001:db8::/32 [Reserved for documentation]
        - MIX
            This->    2001 : 0db8 : 0000 : 1111 : 0000 : 0000 : 0000 : 0200
            Becomes-> 2001 :  db8 :    0 : 1111 :                    :  200

    Improvements IPv6 provides:
        Increased address space: IPv6 128b(340 undecillion addresses) hierarchical addressing as opposed to IPv4 with 32b(4,294,967,296 addresses).
        Improved packet handling: The IPv6 header has been simplified with fewer fields.
        Eliminates the need for NAT: This avoids some of the NAT-induced problems experienced by applications that require end-to-end connectivity.

    IP configuration: 
        - Manual: 
            On a R:
                R(config)#ipv6 unicast-routing  [Allow R to forward IPv6 packets]
                R(config)#interface g0/2
                R(config-if)#ipv6 address 2001:0db8:0000:0002:0000:0000:0000:0001/64    [in the network 2001:db8:0:2::/64][A LLA will be automatically configured simultaneously FE80::]
                R(config-if)#no shutdown
                R#show ipv6 interface brief
                NOTE: 'Dual stack' means having IPv5 and IPv6 at same time to slowly transition to IPv6
                Modified EUI-64:
                    R(config)#ipv6 unicast-routing  [Allow R to forward IPv6 packets]
                    R(config)#interface g0/2
                    R(config-if)#ipv6 address 2001:0db8:0000:0002:0000:0000:0000:0000/64 eui-64 [Tells the R to use this prefix + the eui-64 method from MAC to build its IPv6 address]
                        Address will be 2001:0db8:0000:0002:0EF8:22FF:FE36:8502/64  [In case the MAC is '0CF8:2236:8502']
                    R(config-if)#no shutdown
                    R#show ipv6 interface brief
            On a workstation: 
                Settings/netsh OR iw>interface
        - Dynamic: 
         When DHCPv6 or SLAAC is used, the LLA of the R will automatically be specified as the DGway address.
            - SLAAC(Stateless add auto config)[Not obtained by DHCP][GUA]
                PC obtaining LinkLocal is not routable like APIPA, so it sends {R Solicitation} to its DGway and gets a {R advertisiment[only the prefixID]} then PC uses it on its existing InterfaceID to create a routable address
            - DHCPv6(stateful): 
                - Stateless: Giving the PC a prefixID only, and let the PC uses its existing InterfaceID
                - Stateful[GUA]: Giving the PC the full adress, prefixID+InterfaceID
    
    Address Grouping: 
        - Unicast: 
         An IPv6 unicast address uniquely identifies an interface on an IPv6-enabled device.
            - Global unicast Address(GUA)
             Public which can be used over the internet.
             Needs to be registered. Leading bits 001[2&3] which is 2000::/3(2000:: to 3FFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF) + All addresses which are not reserved for other purposes
                (2000) 001|0 0000 0000 0000 ~ (3fff) 001|1 1111 1111 1111 
                Components:
                    - Global routing prefix[GRP](Network ID)-> 48b
                        2001:db8:acad::/48 has a GRP 48 bits (3 hextets) (2001:db8:acad)[size of the GRP determines the size of the subnet ID.]
                    - Subnet ID-> 16b
                        Unlike IPv4 where you must borrow bits from the host portion to create subnets, identify subnets within an organization's site
                        48b GRP means 16b Subnet ID that will result in 65 thousand subnets, each with 18 quintillion devices per subnet.
                        Using a typical /64 prefix length, the first 4 hextets are the network portion, with the fourth hextet indicating the Subnet ID.
                    - Interface ID(host portion)-> 64b  [Uses the EUI-64 rules]
                NOTE: 
                    In IPv6, the all-0s and all-1s host addresses can be assigned to a host. 
                        For "all-1s" because no BC used within IPv6. 
                        For "all-0s" can also be used, but is reserved as a Subnet-router anycast address, and should be assigned only to Rs.
                Configuration:
                    Static: 
                        On a R:
                            R1(config)# interface serial 0/1/0
                            R1(config-if)# ipv6 address 2001:db8:acad:3::1/64
                            R1(config-if)# no shutdown
                            R1(config)# interface gigabitethernet 0/0/0
                            R1(config-if)# ipv6 address 2001:db8:acad:1::1/64
                            R1(config-if)# no shutdown
                            R1(config-if)# exit
                        On a host: Like IPv4, Using the LLA of the R as the DGway is best practice
                    Dynamic: Through Internet Control Message Protocol (ICMPv6) messages. To enable ipv6 routing-> "ipv6 unicast-routing"
                        ICMPv6 RA: 
                         Rs Ethernet interfaces send to all nodes, 
                         if SLAAC-> RA includes prefix, prefix-length, DGway info. It is a suggestion to a node on how to obtain an UPv6 GUA. Node's OS make the ultimate decision.
                            Components:
                                Net-prefix & prefix-length:     Tells the device which network it belongs to.
                                DGway address:                  Is an IPv6 LLA (The Src.IPv6 of the RA message)
                                DNS addresses and domain name:  Addresses of DNS servers and a domain name.
                            Methods:
                                - SLAACs: 
                                    - Stateless Address Auto-Configuration(SLAAC): 
                                     Stateless means no [central server(Stateful DHCPv6 Server)] to alocate GUAs or to keeping a list of devices and their addresses
                                     Hosts use the RS/RA messages to learn the IPv6 prefix of the local link and then automatically generate an IPv6 address
                                        'ipv6 address autoconfig' command does not need the prefix length to be manually entered, devices uses NDP to learn the prefix used on the local link.
                                     The devices will use EUI-64 to generate the interface ID, or it will be randomly generated(Depending on the device/maker)
                                        Components:
                                            1- R sends RA: 
                                                RA message with prefix of the local link “I have everything you need including the prefix, prefix-length, and DGeway address.”
                                                Suggests devices use the following:
                                                    SLAAC->                     To create its own IPv6 GUA
                                                    The R LLA->                 which is the RA Src.IPv6 address, to use it as the DGway address
                                            2- PC: 
                                                Uses SLAAC to obtain a prefix from the RA and creates its own interface ID
                                                The address is created as following:
                                                    Prefix:       is advertised in the RA message.
                                                    Interface ID: Created by client OS using the "EUI-64" process OR by generating a "random 64-bit" number, depending on the device OS.
                                                        - EUI-64(Extended Unique Identifier):
                                                         Uses the 48b MAC of a client, inserts another 16b in the middle of the 48b, and invert the U/L bit to create a 64b interface ID.
                                                            MAC addresses are usually represented in hexadecimal and are made up of two parts:
                                                                OUI: 24b (6 HEX digits) vendor code assigned.
                                                                Device Identifier: Unique 24b (6 HEX digits) value within a common OUI.
                                                        - Randomly Geenerated:
                                                            Beginning with Windows Vista, Windows uses a randomly generated. Windows XP and previous Windows OS used EUI-64.
                                        Benefits:
                                            Allows a device to create its own GUA without the services of DHCPv6. 
                                            Devices will rely on the ICMPv6 RA messages of the local R to obtain the necessary info. 
                                    - SLAAC with a stateless DHCPv6 server: 
                                     R interface can be configured to send a RA using SLAAC and stateless DHCPv6.
                                     When the RA message is either SLAAC OR SLAAC with stateless DHCPv6, the client must generate its own interface ID.
                                        Components:
                                            1- R sends RA:
                                                RA message with prefix of the local link “I have everything you need including the prefix, prefix-length, and DGeway address.”
                                                Suggests that the receiving device use this info to create its own IPv6 GUA and all other necessary information.
                                            2- PC:
                                                Uses SLAAC to obtain a prefix from the RA and creates its own interface ID
                                                The address is created as following:
                                                    Prefix:       is advertised in the RA message.
                                                    Interface ID: Created by client OS using the "EUI-64" process OR by generating a "random 64-bit" number, depending on the device OS.
                                                        - EUI-64(Extended Unique Identifier):
                                                         Uses the 48b MAC of a client, inserts another 16b in the middle of the 48b, and invert the U/L bit to create a 64b interface ID.
                                                            MAC addresses are usually represented in hexadecimal and are made up of two parts:
                                                                OUI: 24b (6 HEX digits) vendor code assigned.
                                                                Device Identifier: Unique 24b (6 HEX digits) value within a common OUI.
                                                        - Randomly Geenerated:
                                                            Beginning with Windows Vista, Windows uses a randomly generated. Windows XP and previous Windows OS used EUI-64.
                                        Functionality:
                                            1- PC sends RS to all IPv6 Rs:
                                                "I need info"
                                            2- R sends RA to all IPv6 nodes with (SLAAC & DHCPv6):
                                                "Here is your prefix, prefix-length, DGway. But you need DNS info from a stateless DHCPv6 server"
                                                Suggests devices use the following:
                                                    SLAAC->                     To create its own IPv6 GUA
                                                    The R LLA->                 which is the RA Src.IPv6 address, to use it as the DGway address
                                                    A stateless DHCPv6 server-> To obtain other information such as a DNS server address and a domain name
                                            3- PC sends DCHPv6 Solicit message to all DHCPv6 servers:
                                                "I used SLAAC, and now I need other info from a stateless DHCPv6 server"
                                            4- A stateless DHCPv6 server:
                                                Distributes DNS server addresses and domain names. It does not allocate GUAs.
                                    Duplicate Address Detection(DAD):
                                     Any time an IPv6-enabled interface initializes ('no shutdown' command), or an IPv6 is configured on an interface it performs DAD To ensure the IPv6 uniqueness.
                                     Similar to an ARP req for its own address. If there is no reply, then the address is unique.
                                        1- Sending neighbour Solicitation(NS): 
                                            Sending NS to its own IPv6 address, to confirm that no one conflicts with their obtained IP, 
                                        2- Then confirms on other nodes that he will start using this IPv6 with neighbour advertisiment(NA)
                                - Stateful DHCPv6 (no SLAAC)[Similar to DHCPv4]: 
                                 R interface can be configured to send an RA using stateful DHCPv6 only.
                                 A stateful DHCPv6 server: Allocates and maintains a list of which device receives which IPv6 address. DHCP for IPv4 is stateful.
                                    1- PC sends RS to all IPv6 Rs                               "I need addressing info"
                                    2- R sends RA to all IPv6 nodes with (Stateful DHCPv6)      "I am your DGway. But ask a stateful DHCPv6 server for your IPv6 and other info"
                                    3- PC sends a DHCPv6 solicit message to all DHCPv6 servers. "I received my DGway info. I need an IPv6 and all other info from a stateful DHCPv6 server"
                                        RA message suggests devices use the following:
                                            R LLA->                     which is the RA Src.IPv6 address, for the DGway address.
                                            A stateful DHCPv6 server->  To obtain a GUA, DNS server address, domain name and other necessary information.
                                        NOTE: 
                                            DGway info can only be obtained dynamically from the RA message. The stateless or stateful DHCPv6 server does not provide the DGway address.
                        ICMPv6 RS: 
                         A request for an RA message. Send from all hosts to their R, requesting address info.
                         IPv6 Rs periodically send out ICMPv6 RA messages, every 200sec, to all IPv6-enabled hosts on the network. 
                        NOTE:
                            RA message will also be sent in response to a host sending an ICMPv6 RS message
                                - Stateless Address Autoconfiguration (SLAAC)
                                - Stateful DHCPv6
            - Unique-Local Address(ULA):
             Private which cannot be be used over the internet. They are routable within a link.
             Do not need to be registered. They are FC00::/7(FC00:: to FDFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF) -> Later update requires the 8th bit to be set to 1, so first two digits must be FD
                (FD00) 1111 1101 0000 0000 ~ (FDFF) 1111 1101 1111 1111
                Components:
                    ULA indicator-> 8b
                        FD45:93AC:8A8F:0001:0000:0000:0000:0001/64 has a ULA ID 8 bits (1st half of 1st hextet) (FD)[Identifies that this is a ULA]
                    - Global ID-> 40b
                        FD45:93AC:8A8F:0001:0000:0000:0000:0001/64 has a GI 40 bits (2 and a half hextet) (45:93AC:8A8F)[Should be randomly generated, for uniquiness if companies merged]
                    - Subnet ID-> 16b
                        8b ULA ID and 40b Global ID means 16b Subnet ID that will result in 65 thousand subnets, each with 18 quintillion devices per subnet.
                        Using a typical /64 prefix length, the first 4 hextets are the network portion, with the fourth hextet indicating the Subnet ID.
                    - Interface ID(host portion)-> 64b
            - Link-Local Address(LLA):
             Link-Local means that the addresses are used for communication within a single link(subnet). Rs will not route packets with LLA Dst. Ipv6
             Private Automatically generated on IPv6-enabled interfaced('ipv6 enable' command) which cannot be be used over the internet.
             Do not need to be registered. They are FE80::/10(FE80:: to FEBF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF) -> the 54 bits after the FE80/10 should all be 0s, so you wont see LLA beggining with FE9, FEA, or FEB. Only FE8
                (FE80) 1111 1110 0000 0000 ~ (FEBF) 1111 1110 1011 1111
                Uses:
                    - Routing protocols peering [OSPFv3 uses LLA addresses for neighbor adjacencies]
                    - next-hop addresses for static routes
                    - Neighbor Discovery Protocol   [NDP, IPv6 replacement for ARP] uses LLA to function
                    - LLA of the R, and not the GUA, used as the DGway for hosts on same link. LLAs are not included in the routing table of the R because they are not routable addresses.                               
                Configuration:
                    Statically: host has been manually configured.
                        On a R: fe80::n:1
                            R1(config)# interface gigabitethernet 0/0/0
                            R1(config)#ipv6 enable  [to enable ipv6 on interface]
                            R1(config-if)# ipv6 address fe80::1:1 link-local
                            R1(config-if)# exit
                            R1(config)# interface serial 0/1/0
                            R1(config-if)# ipv6 address fe80::3:1 link-local
                            R1(config-if)# exit
                        NOTE: Exact same LLA can be configured on each link. Because LLAs only have to be unique on that link.
                    Dynamically: 
                        Rs create an IPv6 whenever a GUA is assigned to the interface using EUI-64. 
                        For serial interfaces, the R uses the MAC of an Ethernet interface[Serials do not have MAC].
                        Drwaback would be its long interface ID makes it challenging to identify and remember assigned addresses.
                        host creates its own interface ID using randomly generated values OR using the Extended Unique Identifier (EUI) method, using MAC address along with additional bits.
            - Site-local(Private)[cancelled now]: 
                fec0::/10 
            - Loopback:
                ::1/128 -> 127.0.0.0/8
                Used to test the protocol stack on the local device
                Messages sent to this address are processed within the local device, but not sent to other devices
            - Unspecified address:
                :: [::0/128 -> 0.0.0.0] -> 0.0.0.0
                Can be used when a device does not yet know its IPv6 address
                IPv6 default routes are configured ::/0
            - Embeded IPv4
        - Multicast: 
         An IPv6 multicast address is used to send a single IPv6 packet to multiple destinations. 
         Its block is FF00::/8(FF00:: to FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF)
            (FF00) 1111 1111 0000 0000 ~ (FFFF) 1111 1111 1111 1111 
            Types:
                Well-known: 
                 Assigned, reserved for predefined groups of devices. 
                 A Single address used to reach a group of devices running a common protocol or service
                    Common Types:
                        All nodes/hosts like BC:
                            ff02::1 -> 224.0.0.1
                            Acts like IPv4 BC, all IPv6-enabled devices join. 
                            An IPv6 R sends ICMPv6 RA messages to the all-node multicast group.
                            A packet sent to this group is received and processed by all IPv6 on the link or network. 
                        All Rs:
                            ff02::2 -> 224.0.0.2
                            All IPv6 Rs join. A R becomes a member of this group when it is enabled as an IPv6 R with the "ipv6 unicast-routing". 
                            A packet sent to this group is received and processed by all IPv6 Rs on the link or network.
                        All OSPF Rs:
                            ff02::5 -> 224.0.0.5
                        All OSPF DRs/BDRs:
                            ff02::6 -> 224.0.0.6
                        All RIP Rs:
                            ff02::9 -> 224.0.0.9
                        All EIGRP Rs:
                            ff02::A -> 224.0.0.10
                Solicited-node: 
                 Similar to the all-nodes, but it is mapped to a special Ethernet multicast address.
                 Allows the NIC to filter the frame by examining the Dst.MAC without sending it to the IPv6 process to see if the device is the intended target of the IPv6 packet.
                    Calculation:
                     Calculated from a unicast address
                        ff02::1:ff + Last 6 HEX digits of unicast address
                            2002:0db8:0000:0001:0f2a:4fff:fe|a3:00b1 -> ff02::1:ff|a3:00b1
                    Neighbor Discovery Protocol(NDP):
                     Has various functions, and one of those functions is to replace ARP.
                        Uses ICMPv6 and Solicited-node multicast addresses to learn the MAC of other hosts.
                        Instead of ARP table, the R will store the information in the Neighbor table.
                     Allows hosts to automatically discover Rs no the local network
                        Messages type:
                            Like-ARP:
                                Neighbor Solicitation(NS):
                                    ICMPv6 type 135 -> equivalent to ARP request
                                Neighbor Advertisement(NA):
                                    ICMPv6 type 136 -> equivalent to ARP reply
                            R Discovery:
                                Router Solicitation(RS):
                                    ICMPv6 type 133
                                    Sent to multicast address ff02:2 (all Rs)
                                    Asks all Rs on the local link to identify themselves
                                    Sent when an interface is enabled/host is connected to the network
                                Router Advertisement(RA):
                                    ICMPv6 type 134
                                    Sent to multicast address ff02:1 (all nodes)
                                    The R announces its presence, as well as other info about the link
                                    These messages are sent in reponse to RS messages
                                    They are also sent periodically, even if the R has not received an RS
            Scope:
             Indicates how far the packet should be forwarded
                Interface-Local:
                    FF01
                    Does not leave the local device. Can be used to send traffic to a service within the local device.
                Link-Local:
                    FF02
                    Does remains in the local subnet. Rs will not route the packet between subnets.
                Site-Local:
                    FF05
                    Can be forwarded by Rs. Should be limited to a single physical location (not forwarded over a WAN)
                Organization-Local:
                    FF08
                    Wide in scope than site. An entire company.
                Global:
                    FF0E
                    No boundries. Possible to be routed over the internet
        - Anycast: 
         one-to-nearest/one-to-one-of-many by metric.
         Any IPv6 unicast address that can be assigned to multiple devices. A packet sent to an anycast address is routed to the nearest device having that address.
            - Mutliple Rs are configured with the same IPv6.
                They use a routing protocol to advertise the address
                When hosts send packets to that Dst. address, Rs will forward it to the nearest R configured with that IP (based on routing metric)
            - No specific address range. Using a regular unicast address (GUA, ULA) and specify it as an anycast address
            - Configuration:    
                R(config-if)#ipv6 address 2001:db8:1:1::99/128 anycast
    
    Subnetting:
        A separate subnet ID field in the GUA is used to create subnets. In is the area between the Global Routing Prefix and the interface ID. Global 
        Routing Prefix(48b) + Subnet ID(16b) + Interface ID(64b) = A /48 routing prefix + 16b subnet ID = /64 prefix
            16-bit subnet ID: Creates up to 65,536 subnets. To determine the next available subnet, just count up in hexadecimal. Only the subnet ID hextet is incremented in hexadecimal.
                Unlinke IPv4, in IPv6 The serial link between R1 and R2 subnet will have the same prefix length as the LANs
                2001:db8:acad::/48 = 16b subnet ID = 65,536 /64 subnets = 2001:db8:acad:0000::/64 ~ 2001:db8:acad:ffff::/64
            64-bit interface ID:    Supports up to 18 quintillion host IPv6 addresses per subnet (i.e., 18,000,000,000,000,000,000).
            Note: Subnetting into the 64-bit interface ID (or host portion) is also possible but it is rarely required.
    
    The migration techniques:
        Dual stack: allows IPv4 and IPv6 to coexist on the same network. Known as native IPv6, means the network has an IPv6 connection to its ISP and is able to access internet over IPv6.
        Tunneling: transporting an IPv6 packet over an IPv4 network. The IPv6 packet is encapsulated inside an IPv4 packet, similar to other types of data.
        Transition: An IPv6 packet is translated to an IPv4 packet and an IPv4 packet is translated to an IPv6 packet. Network Address Translation 64 (NAT64) allows IPv6-enabled devices to communicate with IPv4-enabled devices using a translation technique similar to NAT for IPv4.




- IPv6 header: 
 40 bytes, FIXED format -> IPv4 has varialbe header from 20~60
    Version + TrafficClass + FlowLabel + PayloadLength + NextHeader + HopLimit + EH + Src.&Des.IP
        - Version: 4b
            set to 6(0b0110) that identifies this as an IP version 6 packet.
        - Traffic Class(Same as DS): 8b 
            equivalent to the IPv4 Differentiated Services (DS) field.
            Used for QoS
        - Flow Label: 20b 
            Suggests that all packets with the same flow label receive the same type of handling by Rs.
        - Payload Length: 16b 
            Indicates the length of the data portion or payload of the IPv6 packet(L4 Segment). The length of the IPv6 header itself is not included, bec it is always 40 bytes.
        - Next Header(same as protocol): 8b 
            It indicates the data payload type that the packet is carrying(TPC or UDP), enabling the network layer to pass the data to the appropriate upper-layer protocol.
        - Hop Limit: 8b 
            Replaces the IPv4 TTL field. 
            Decremented by a value of 1 by each R that forwards the packet. 
                When the counter reaches 0, the packet is discarded, and an ICMPv6 Time Exceeded message is forwarded to the sending host,. 
                    This indicates that the packet did not reach its destination because the hop limit was exceeded. 
            NOTE: 
                Unlike IPv4, IPv6 does not include an IPv6 Header Checksum, because this function is performed at both the lower and upper layers. 
                This means the checksum does not need to be recalculated by each R when it decrements the Hop Limit field, which also improves network performance.
        - extension headers (EH):
            provide optional network layer information. 
            optional and are placed between the IPv6 header and the payload. 
            used for fragmentation, security, to support mobility and more. [Unlike IPv4, Rs do not fragment routed IPv6 packets]
        - Source IPv6 Address: 128b 
            identifies the IPv6 address of the sending host.
        - Destination IPv6 Address: 128b 
            identifes the Pv6 address of the receiving host.




Services:
    Remote Login:
        telnet:
            1- Connectivity: 
            2- Ip addresses (Src. & Dst.)
            3- Passwd: (Enable & VTY )
        SSH:
            1- create local account: "username admin secret/password yourPass"
            2- Generate encryption key: "ip domain-name cisco.com"> "crypto key generate rsa"
            3- define login protocol: "line vty 0">"login local">"transport input telnet/ssh/all"

    File Server:
        FTP(TCP): 
            Secure user/passwd. 
            Any file size. 
            Backup:
                (conf)#ip ftp username yourUsername
                (conf)#ip ftp password yourPasswd
                #copy runnining-config FTP
                #show flash  (Src.FileName)
                #copy flash FTP
            Restore:
                (conf)#interface vlan 1
                (conf-if)#ip address yourIpAddress
                (conf-if)#no shutdown
                (conf)#ip ftp username yourUsername
                (conf)#ip ftp password yourPasswd"
                #copy FTP runnining-config
                #copy FTP flash     (Intermediary boot lowest index .bin file) 
                (conf)#boot system flash:yourBinFile.bin
                    OR
                (conf)#boot system flash:FTP://10.0.0.10/yourBinFile.bin"
                #delete file yourFileName
                #erase file yourFileName
        TFTP(UDP): 
            No security, no authentication. 
            Small files size 32mega max. 
            Backup:
                R#copy runnining-config TFTP
                R#show flash    (Src.FileName)
                R#copy flash TFTP"
            Restore:
                R(conf)#interface vlan 1
                R(conf)#ip address yourIpAddress
                R(conf-if)#no shutdown
                R#copy TFTP runnining-config
                R#copy TFTP flash
                R(conf)#boot system flash:yourBinFile.bin
                    OR
                R(conf)#boot system flash:TFTP://10.0.0.10/yourBinFile.bin
                #delete file yourFileName
                #erase file yourFileName

    Port Security
        Disable any unused port
        MAC filtering to prevent abusing usage of existing ports
        switchport
            switchport access (to end devices)
            switchport port-security
            switchport port-security MAC-address yourMACAddress/sticky/max 1-132 
            switchport port-security violation strict
                Violation Modes-> 
                    shutdown-> Error Disable ("shutdown" then "no shutdown")
                    restrict-> no port disabling, drops data, send log messages "show logging"
                    protect->  no port disabling, drops data, does not send logs
        Port based authentication

    First Hop Redundancy Protocol(FHRP):
        Purpose: 
            Designed to protect the default gateway used on a subnetwork by allowing two or more Rs to provide backup for that address; in the even of failure of an active R, the backup R will take over the address, usually within a few seconds
        Functionality:
            The Rs sends Hello multicast messages to negotiate the active/standby and shares a VirtualIP & VirtualMAC. 
            If no Hellow message recevied by the Standby R, it assumes that the Active R is down and starting of taking over. 
                The new Active R sends Gratuitous ARP reply(Sent without being requested, its frames are broadcast) to update the Virtual MAC entry.
            If the down R came back again online, it will be the standby and will not take its place back
                FHRP are 'non-preemptive', the current active R will not automatically give up its role, even if the former active R returns
                Can be manually manipulated, and make R1 'preempt' R2 and take back its active role automatically
        Key concepts:
            Virtual IP: Configured on the two Rs
            Virtual MAC: Generated for the virtual IP(Each FHRP uses a different format for the virtual MAC)
            Active & Standby: Are elected (Different FHRP use different terms)
        Types:
            Hot Standby R Protocol(HSRP):
                Functionality:
                    Cisco Proprietary
                    An Active and Standby R are elected
                    Multiple subnets/VLANs: You can configure a different active R in each subnet/VLAN to load balance
                    Active R is determined in this order:
                        - Highest priority(Defualt 100)
                        - Highest IP address
                Versions:
                    1: 
                        Multiast Hello messages: 224.0.0.2
                        Virtual MAC address:        0000.0c07.acxx  [xx = HSRP group number]
                    2: 
                     Adds IPv6 support and increases the number of groups that can be configured
                        Multiast Hello messages: 224.0.0.102
                        Virtual MAC address:        0000.0c9f.fxxx  [xxx = HSRP group number]
                Configuration:
                    R1(config)#interface g0/0
                    R1(config-if)#standby version 2
                    R1(config-if)#standby <0~255>GroupNumber ip ipAddr
                    R1(config-if)#standby <0~255>GroupNumber priority theNumber
                    R1(config-if)#standby <0~255>GroupNumber preempt 
                    R1(config-if)#show standby
                    NOTE: 
                        Group numbers and protocol versions have to match between Rs
                        Tracert tool replies with the actual IP of the active/master DGway instead of the configured virtualIP
            Virtual R Redundancy Protocol(VRRP):
                Functionality:
                    Open standard
                    A Master and Backup R are elected
                    Multiple subnets/VLANs: You can configure a different active R in each subnet/VLAN to load balance
                    Multiast Hello messages: 224.0.0.18
                    Virtual MAC address:     0000.5e00.01xx  [xxx = VRRP group number]
            Gateway Loadbalancing Protocol(GLBP):
                Functionality:
                    Cisco proprietary
                    An Active Virtual GWay(AVG) is elected
                    Up to 4 Active Virtual Forwarders(VFs) are assigned by the AVG(The AVG itself can be an AVG, too)
                        Each AVF acts as the default GWay for a portion of the hosts in the subnet
                    Multiast Hello messages: 224.0.0.102
                    Virtual MAC address:     0007.b400.xxyy  [xx = GLRP group number, yy= AVF number]

    Access Control List(ACL):
     ACLs function as a packet filter, instructing the R to permit or discard specific traffic
     Can filter based on Src./Dst. Ip, Src./Dst. L4 ports, etc.
        - Operations:
            = Stracture:
                ACLs are made up of one or more ACEs
                They are an ordered sequence of Access Control Entries(ACEs)
            = Effective Configuration:
                ACLs are conigured globally on the R [Global Config Mode]
                Configuring an ACL in Config mode will not make the ACL take effect. It must be applied to an interface with a direction specified.
            = Directions:
                Directions appllied either inbound(from medium to interface) or outbound(from interface to medium). 
                A maximum of one ACL can be applied to a single interface per direction. Inbound: Maximum one ACL, Outbound: Maximum one ACL
            = Logic:
                When the R checks a packet against ACL, it processes the ACEs in order, from top to bottom
                If the packet matches one of the ACEs in the ACL, the R takes the action and stops processing the ACL. All entries below the matching entry will be ignored
                There is an 'Implicit deny' at the end of all ACL even if not configured
                    Tells the R to deny all trafiic that does not match any of the configured entries in the ACL
        - Types:
            - Standard:
                = Functionality:
                    Match based on [Src.IP] only
                    Numbered ACL range: 1~99 and 1300~1999
                    Should be applied as close to the Dst. as possible
                = Subtypes:
                    = Standard Numbered ACLs:
                        Functionality:
                            Numbered ACLs are identified with a number (ie. ACL 1, ACL 2, etc.)
                        Configuration:
                            Creating ACLs:
                                R(config)#access-list 1 deny 1.1.1.1 0.0.0.0
                                R(config)#access-list 1 deny 1.1.1.1
                                R(config)#access-list 1 deny host 1.1.1.1
                                R(config)#access-list 1 permit any
                                R(config)#access-list 1 permit 0.0.0.0 255.255.255.255
                                R(config)#no access-list 1 permit 0.0.0.0 255.255.255.255  [DO NOT USE, will delete the whole access-list not just this ACE]
                                R(config)#access-list 1 remark ## Blocking BOB from Accounting ##   [Description]
                                                    OR
                                R(config)#ip access-list standard 1
                                R(config-std-nacl)#5 deny 1.1.1.1
                                R(config-std-nacl)#10 permit any
                                R(config-std-nacl)#no 5
                                R(config-std-nacl)#remark ## Blocking BOB from Accounting ##   [Description]
                                R(config-std-nacl)#6 deny 2.2.2.2 [Inserting new entries in between others with the sequencing number]
                                R(config)#ip access-list resequence ACL-ID Starting-Seq-Num Increament [to resequence the ACEs, allows to configure spaces in between to modify when needed]
                            Applying to interfaces:
                                R(config)#interface g0/0
                                R(config-if)#ip access-group 1 out
                            Displays:
                                R#show access-list      [Displays all ACLs]
                                R#show ip access-list   [Displays only IP ACLs]
                                R(config)#show running-config | include access-list
                    = Standard Named ACLs:
                        Functionality:
                            Named ACLs are identified with a name (ie. "Block_Bob")
                            Configured by entering 'Standard Named ACL' "config mode", and then configuring each entry within that config mode
                        Configuration:
                            Creating ACLs:
                                R(config)#ip access-list standard Block_Bob
                                R(config-std-nacl)#5 deny 1.1.1.1
                                R(config-std-nacl)#10 permit any
                                R(config-std-nacl)#no 5
                                R(config-std-nacl)#remark ## Blocking BOB from Accounting ##   [Description]
                                R(config-std-nacl)#6 deny 2.2.2.2 [Inserting new entries in between others with the sequencing number]
                                R(config)#ip access-list resequence ACL-ID/Word Starting-Seq-Num Increament [to resequence the ACEs, allows to configure spaces in between to modify when needed]
                            Applying to interfaces:
                                R(config)#interface g0/0
                                R(config-if)#ip access-group Block_Bob in
                            Displays:
                                R#show access-list      [Displays all ACLs]
                                R#show ip access-list   [Displays only IP ACLs]
                                R(config)#do show running-config | section access-list
            - Extended:
                = Functionality:
                    Match based on [Src./Dst.IP, Src./Dst.Port, protocol]
                    Can match traffic based on more parameters, so they are more precise (and more complex) than standard ACLs
                    Numbered ACL range: 100~199 and 2000~2699
                    Should be applied as close to the Src. as possible [To limit how far the packets travel in the network before being denied]
                = Subtypes:
                    = Extended Numbered ACLs:
                        Functionality:
                            Numbered ACLs are identified with a number (ie. ACL 1, ACL 2, etc.)
                        Configuration:
                            Creating ACLs:
                                R(config)#access-list 100 {deny | permit} {tcp/udp} src-ip eq/gt/lt/neq/range src-port dst-ip eq/gt/lt/neq/range dst-port {ack|fin|syn|ttl|dscp}
                                R(config)#access-list 100 deny tcp any 10.0.0.0 0.0.0.255
                                R(config)#access-list 100 deny tcp any host 1.1.1.1 eq 80
                                R(config)#access-list 100 deny udp any range 20000 30000 host 1.1.1.1
                                R(config)#no access-list 100 permit protocol src-ip dst-ip  [DO NOT USE, will delete the whole access-list not just this ACE]
                                R(config)#access-list 100 remark ## Blocking BOB from Accounting ##   [Description]
                                                    OR
                                R(config)#ip access-list extended 100
                                R(config-std-nacl)#5 deny udp 10.0.0.0 0.0.255.255 host 192.168.1.1
                                R(config-std-nacl)#10 permit ip any any
                                R(config-std-nacl)#no 5
                                R(config-std-nacl)#remark ## Blocking BOB from Accounting ##   [Description]
                                R(config-std-nacl)#6 deny protocol src-ip dst-ip [Inserting new entries in between others with the sequencing number]
                                R(config)#ip access-list resequence ACL-ID Starting-Seq-Num Increament [to resequence the ACEs, allows to configure spaces in between to modify when needed]
                            Applying to interfaces:
                                R(config)#interface g0/0
                                R(config-if)#ip access-group 1 out
                            Displays:
                                R#show access-list      [Displays all ACLs]
                                R#show ip access-list   [Displays only IP ACLs]
                                R#show ip inteface g0/0 [Displays in/out name of access-list applied]
                                R#show running-config | include access-list
                    = Extended Named ACLs:
                        Functionality:
                            Named ACLs are identified with a number (ie. "Block_Bob")
                            Configured by entering 'Extended Named ACL' "config mode", and then configuring each entry within that config mode
                        Configuration:
                            Creating ACLs:
                                R(config)#ip access-list extended Block_Bob
                                R(config-std-nacl)#5 deny protocol src-ip dst-ip
                                R(config-std-nacl)#10 permit protocol src-ip dst-ip
                                R(config-std-nacl)#no 5
                                R(config-std-nacl)#remark ## Blocking BOB from Accounting ##   [Description]
                                R(config-std-nacl)#6 deny protocol src-ip dst-ip [Inserting new entries in between others with the sequencing number]
                                R(config)#ip access-list resequence ACL-ID/Word Starting-Seq-Num Increament [to resequence the ACEs, allows to configure spaces in between to modify when needed]
                            Applying to interfaces:
                                R(config)#interface g0/0
                                R(config-if)#ip access-group Block_Bob in
                            Displays:
                                R#show access-list      [Displays all ACLs]
                                R(config)#do show running-config | section access-list
                NOTE: 
                    = If port num with tcp/udp is not specified, all ports will be matched
            - NOTE:
                = R may re-order the /32 entries, it improves the efficiency of processing the ACL and it does not change the effect of the ACL. 
                    This applies to Named/Numbered
                = To specify a /32 Src. or Dst. you have to use the 'host' option or specify the wildcard. You cannot just write the address
                = Automatically assigns an ordered number to each ACE with an increase of 10
                = To disable the implicit deny type 'permit ip any any', or permit ip 0.0.0.0 255.255.255.255

    Dynamic Host Configuration Protocol(DHCP):
        - Purpose:
            Used to allow hosts to automatically/dynamically learn various aspects of their network configuration
                (IP, Subnet Mask, DGway, DNS Server, etc.) without manual/static configuratoin
            Typically used for 'client devices' such as workstation(PC), phones, etc. However, Rs, Servers, etc., are usually manually configured.
        - Functionality:
            = 'ipconfig /release': 
             PC sent a unicast DHCP release message "I do not need this address anymore"
                Magic Cookie: DHCP 
                Options(53):  DHCP message type (Release)
                Options(54):  DHCP Server Identifier (192.168.0.1)
                Options(61):  Client Identifier
                Options(255): End
            = 'ipconfig /renew': 
                PC sent a DHCP request message "I need a new address"
                DORA:
                    - DHCP Discover:
                        BC message from client "Are there any DHCP servers in this network? I need an IP"
                            Src.IP: 0.0.0.0 [since my Src. has no IP yet]
                            Dst.IP: 255.255.255.255
                            UDP: Src.Port: 68, Dst.Port: 67
                            Bootp flags: 0x0000 (unicast)   []
                            Client IP address: 0.0.0.0
                            Client MAC: x:x:x:x:x:x
                            Magic Cookie: DHCP 
                            Options(53):  DHCP message type (Release)
                            Options(61):  Client Identifier
                            Options(50):  Requested IP address (192.168.0.167)      [Prefered, my PC had it before and requesting it again]
                            Options(12):  Host Name
                            Options(60):  Vendor class Identifier
                            Options(55):  Parameter Request List
                            Options(255): End
                    - DHCP Offer:
                        Unicast/BC message from server to the client MAC "How about this IP?"
                            Src.IP: 192.168.0.1 
                            Dst.IP: 192.168.0.167   [Offered IP]
                            UDP: Src.Port: 67, Dst.Port: 68
                            Bootp flags: 0x0000 (unicast)   [DHCP offer can be sent to client using either, BC or Unicast. Depends on the client, like here, PC requested in the Discover to have the IP information sent Unicast]
                            Client IP address: 0.0.0.0
                            Client MAC: x:x:x:x:x:x
                            Magic Cookie: DHCP 
                            Options(53):  DHCP message type (Release)
                            Options(54):  DHCP server Identifier (192.168.0.1)
                            Options(51):  IP address lease time
                            Options(58):  Renewal time value
                            Options(59):  Rebinding time value
                            Options(1):   Subnet Mask (255.255.255.0)
                            Options(28):  Broadcast Address (192.168.0.255)
                            Options(6):   Domain Name Server
                            Options(3):   Router
                            Options(255): End
                    - DHCP Request:
                        BC message from client "I want to use the IP you offered me". There might be several DHCP servers, and client need to specify from which server he's accepting his offer
                            Src.IP: 0.0.0.0 [since my Src. has no IP yet]
                            DST.IP: 255.255.255.255
                            UDP: Src.Port: 68, Dst.Port: 67
                            Bootp flags: 0x0000 (unicast)
                            Client IP address: 0.0.0.0
                            Client MAC: x:x:x:x:x:x
                            Magic Cookie: DHCP 
                            Options(53):  DHCP message type (Release)
                            Options(61):  Client Identifier
                            Options(50):  Requested IP address (192.168.0.167)      [Prefered, my PC had it before and requesting it again]
                            Options(54):  DHCP server Identifier (192.168.0.1)      [Which server the client selected]
                            Options(12):  Host Name
                            Options(81):  Client Fully Qualified Domain Name
                            Options(60):  Vendor class Identifier
                            Options(55):  Parameter Request List
                            Options(255): End
                    - DHCP Ack:
                        Unicast/BC message from server "Okay, you may use it"
                            Src.IP: 192.168.0.1 
                            Dst.IP: 192.168.0.167   [Offered IP]
                            UDP: Src.Port: 67, Dst.Port: 68
                            Bootp flags: 0x0000 (unicast)   [DHCP offer can be sent to client using either, BC or Unicast. Depends on the client, like here, PC requested in the Discover to have the IP information sent Unicast]
                            Client IP address: 0.0.0.0
                            Client MAC: x:x:x:x:x:x
                            Magic Cookie: DHCP 
                            Options(53):  DHCP message type (Release)
                            Options(54):  DHCP server Identifier (192.168.0.1)
                            Options(51):  IP address lease time
                            Options(58):  Renewal time value
                            Options(59):  Rebinding time value
                            Options(1):   Subnet Mask (255.255.255.0)
                            Options(28):  Broadcast Address (192.168.0.255)
                            Options(6):   Domain Name Server
                            Options(81):  Client Fully Qualified Domain Name
                            Options(3):   Router
                            Options(255): End
            = 'Prefered': 
                Address, means this PC was previously assigned that IP by the DHCP server, so it asked to receive the same address again this time
            = 'Lease': 
                DHCP server lease IP to clients. These leases are usually not permanent, and the client must give up the address at the end of the lease.
        - Roles:
                = DHCP role models can be a R to act as the DHCP server for its connected LANs, or, use a centralized DHCP server.
                = In case of centralized, the server will not receive DHCP client's BC DHCP messages(BC messages do not leave the local subnet)
            = Relay:
             To fix above issue, you can configure a R to act as a 'DHCP relay agent'. 
             Therefore, the R will forward the client's BC DHCP messages to the remote DHCP server as unicast messages. 
                Discover:   
                    Client-> Src.: 0.0.0.0, Dst.: 255.255.255.255.    
                    R(Converting the message)-> Src.: the R's port ip that received the message, Dst.: server IP
                Offer:      
                    Server-> Src.: Server IP, Dst.: the R's port ip that sent the message.    
                    R(Converting the message)-> Src.: Server IP, Dst.: Unicast/255.255.255.255
                Request:    
                    Client-> Src.: 0.0.0.0, Dst.: 255.255.255.255.    
                    R(Converting the message)-> Src.: the R's port ip that received the message, Dst.: server IP
                Ack:        
                    Server-> Src.: Server IP, Dst.: the R's port ip that sent the message.    
                    R(Converting the message)-> Src.: Server IP, Dst.: Unicast/255.255.255.255
                Configuration:
                    R(config)#interface g0/0                        (interfce connected to the client devices)
                    R(config-if)#ip helper-address 192.168.10.10    (IP of the DHCP server, make sure it has a route to it statically or dynamically)
                    R(config-if)#do show ip interface g0/1
        - Ports:
            DHCP servers use UDP 67
            DHCP clients use UDP 68
        - Configuration: 
            R as a DHCP server:
                R(config)#ip dhcp excluded-address 192.168.1.1 192.168.1.10 (Specify a range of addresses that will not be given to DHCP clients)
                R(config)#service dhcp                                      (Tells the R to respond to DHCP messages)
                R(config)#ip dhcp pool LAB_POOL                             (Create a separate DHCP pool for each network the R is acing as a DHCP server for)
                R(dhcp-config)#network 192.168.1.0 /24                      (Specify the subnet of addresses to be assigned to clients(except the excluded addresses))
                R(dhcp-config)#dns server 8.8.8.8                           (Specify the DNS server that DHCP clients should use)
                R(dhcp-config)#domain-name jermeysitlab.com                 (Specify the domain name of the network, ie. PC1 = pc1.jeremysitlab.com)
                R(dhcp-config)#default-router 192.168.1.1                   (Specify the DGway, to tell client who is thier DGway)
                R(dhcp-config)#lease 0 5 30                                 (day hours minutes, OR, 'lease infinite')
                R(config)#service dhcp vlan1
                R#show ip dhcp binding
                R#show ip dhcp pool
                R#show ip dhcp server statistics
                NOTE:
                    DHCP Pool: Subnet of addresses that can be assigned to DHCP clients
            R as a DHCP client:
                R(config)#interface g0/0                                    (interfce you want to be a DHCP client, not the whole R)
                R(config-if)#ip address dhcp                                (to make the R a DHCP client and acquire its addresses from the DHCP server)

    Discovery Protocols:
     L2 protocols to share iformation with and discover information about neighboring (connected) devices.  [Information might include L3 info]
     Because they share information about the devices in the network, they can be considered a security risk and are often not used. It is up to the network engineer/admin to decide.
        Type:
            Cisco Discovery Protcol(CDP):
             Cisco Proprietary Protocol, Globally/per interface enabled by default.
                CDP messages: 
                    - Are periodically sent to multicast MAC address 0100.0ccc.cccc
                    - When a device receives a CDP message, it processes and discards the message. It does NOT forward it to other devices. [Only directed connected devices can be CDP neighbors]
                    - By default, CDPv2 messages sent once every 60Sec  [v2 has the capability to identify native VLAN mismatching]
                    - By default, the CDP holdtime is 180Sec. If a message is not received from a neighbor for 180Sec, the neighbor is removed from the CDP neighbor table.
                    - ARPA encapsulation is an Ethernet2 type of encapsulation on the interfaces with CDP enabled
                Configuration:
                    R(config)#[no] cdp run
                    R(config-if)#[no] cdp enable    [Both send and receive]
                    R(config)#cdp timer seconds
                    R(config)#cdp hodltime seconds
                    R(config)#[no] cdp advertise-v2
                    R#show cdp
                    R#show cdp traffic
                    R#show cdp interface [g0/0]
                    R#show cdp neighbors [detail]
                    Rr#show cdp entry [R2]
            Link Layer Discovery Protocol(LLDP):
             Industry Standard Protocol (IEEE 802.1AB). Globally/per interface disabled by default. Can work on same device running CDP.
                LLDP messages: 
                    - Are periodically sent to multicast MAC address 0180.c200.000e
                    - When a device receives a LLDP message, it processes and discards the message. It does NOT forward it to other devices. [Only directed connected devices can be LLDP neighbors]
                    - By default, LLDP messages sent once every 30Sec
                    - By default, the LLDP holdtime is 120Sec. If a message is not received from a neighbor for 120Sec, the neighbor is removed from the LLDP neighbor table.
                    - By default, the LLDP 'reinitialization delay' is 2Sec. If LLDP is enabled, this time will delay the actual initialization to prevent any repid changes
                Configuration:
                    R(config)#[no] lldp run
                    R(config-if)#[no] lldp transmit
                    R(config-if)#[no] lldp receive
                    R(config)#lldp timer seconds
                    R(config)#lldp hodltime seconds
                    R(config)#lldp reinit seconds
                    R#show lldp
                    R#show lldp traffic
                    R#show lldp interface [g0/0]
                    R#show lldp neighbors [detail]
                    R1#show lldp entry [R2]
        Functionality:
            R!: 
                "Hi, I am R1. I am a router. You are connected to my G0/1 interface. My IP address on this interface is 10.0.0.1
            SW1:
                "Hi, I am SW1. You are connecteed to my G0/0 interface."    [SW has no IP address to share]

    Network Time Protocol(NTP):
     All devices have an internal clock (Rs, SWs, PCs, etc.)
        Functionality:
            Manually configuring clocks will drift, resulting in inaccurate time.
            NTP allows automatic syncing of time over a network
            NTP clients request the time from NTP servers
            A device can be an NTP server and an NTP client at the same time
            NTP allows accuracy of time within ~1 milliseconds if the NTP server is in the same LAN, or within ~50 milliseconds if connecting to the NTP server over a WAN/the Internet
            NTP uses UDP port 123 to communicate
            NTP uses UTC by default, and does not update the calendar by defualt.
        Stratum:
            The 'distance' of an NTP server from the original 'reference clock'. Some NTP servers are 'better' than others.
            Servers with lower stratum levels are preferred.
            Reference clock:
                Usually a very accurate time device like an atomic clock or a GPS clock
                NTP Heirarchy:
                    Rerence clocks:
                        Stratum 0 and they are the Original time sources
                    S1(Primary servers): 
                        Stratum 1 NTP servers get their time from reference clocks
                        Any secondary server, operate in server mode and client mode a the same time
                    S2(Secondary Servers):
                        Stratum 2 NTP servers get their time from S1 servers 
                    S3(Secondary Servers):
                        Stratum 3 NTP servers get their time from S2 servers 
                    ~S15(Secondary Servers):
                        Stratum 15 is the maximum. Anything above that is considered unreliable
                Peering(Symmetric active mode):
                    Devices can also 'peer' with devices at the same stratum to provide more accurate time. Works as a backup in case one of them loses access to above stratum.
        Modes:
         A device can be all three below at the same time
            Server Mode
            Client Mode:
                Can sync to multiple NTP servers
            Symmetric active mode
        NTP Authentication:
            Optional, allows NTP clients to ensure they only sync to the intended servers.
        Configuration:
            Manual:
                R#clock set hh:mm:ss day/month month/day/year       (software clock)
                R#calendar set hh:mm:ss day/mooth month/day/year    (Hardware clock)
                R(config)#clock timezone nameOfZone hoursOfSet [minutsOfSet] (time zone configuration)
                R#clock summer-time nameOfZone recurring/date startWeekOfTheMonth weekDay Month time startWeekOfTheMonth weekDay Month time [offset]    (summer time)
                                                            [ Start of Day Light Saving Time(DST)] [  End of Day Light Saving Time(DST) ]
                R#{clock | ntp} update-calendar                     (sync the calendar to the clock's time)
                R#clock read-calendar                               (sync the clock to the calendar's time)
            Static Client Mode:
                R#ntp server serverIP           (Can enter multiple NTP servers)
                R#ntp server serverIP prefer    (makes this the prefered NTP server)
            Server Mode:
                R2(config)#ntp srouce looback0  (loobacks are better in case the connection between the two Rs fails, it still advertises the NTP messages to their peers)
                R2(config)#ntp master [stratum] (device will act as a reference clock with no syncronizing to other NTP server, by default its stratum level is 8 and its loopback address is 7)
            Symmetric Active Mode:
                R1(config)#ntp peer 10.0.23.2
                R2(config)#ntp peer 10.0.23.1
            NTP Authentication:
                On server/Master:
                    R1(config)#ntp authenticate                             (Enable NTP)
                    R1(config)#ntp authenticateion-key key-number md5 key   (Create the NTP Auth key)
                    R1(config)#ntp trusted-key key-number                   (Specify the  NTP Trusted key)
                On peers/Clients:
                    R2(config)#ntp authenticate                             (Enable NTP)
                    R2(config)#ntp authenticateion-key key-number md5 key   (Create the NTP Auth key)
                    R2(config)#ntp trusted-key key-number                   (Specify the  NTP Trusted key)
                    R2(config)#ntp server server-ip key key-number          (Sepcify which NTP key to use for the server)
                    R2(config)#ntp peer server-ip key key-number            (Specify NTP Auth with peers)
            Displays:
                R#show ntp associations
                R#show ntp status               (Because our R is syncronizing its time to other NTP servers, it automatically becomes an NTP server itself with a stratum level 1 higher than the ones syncronizing to)
                R#show clock [detail]   ('*' means time is not considered authoritative, the hardware calendar is the default time source and it drifts over time)
                R#show logging
                NOTE:
                    - The hardware clock(calendar) tracks the date and time on the devices even if it restarts, power is lost, etc. When the system is restarted, 
                        the hardware clock is used to initialize the software clock.

    Domain Name System(DNS):
        Purpose:
            Used to 'resolve/convert' human-readable names to IP addresses.
            Machines do not use names, they use addresses that are then converted to binary
            Once you type 'youtube.com' into a web browser, your device will ask a DNS server for the IP address of youtube.com
            Can be manually configured or learned via DHCP. Rs simply forward packets and no DNS configuration is required on Rs
            Standard DNS queries/responses uses UDP port 53, TCP port 53 if the DNS messages greater than 512 bytes.
        Functionality:
         Cisco R can be configured as a DNS server/client. If internal DNS server is used, usually it is a Windows or Linux server.
            DNS server:
                As in the case of R being DNS server with entries
            DNS client:
                As in the case of R being forwarding the DNS query to its configured external last-resort DNS for unfound entries on its own.
            Records:
                'A':
                    Maps names to IPv4 addresses
                'AAAA':
                    Maps names to IPv6 addresses
        Configuration:
            R as DNS server:
                R(config)#ip dns server
                R(config)#ip host R1 192.168.0.1
                R(config)#ip name-server 8.8.8.8    (R will query from it if the requested record is not in its host table)
                R(config)#ip domain lookup          (enable R to perform DNS queries)
                R(config)#ip domain name            (configure the default domain name)
            Displaying on hosts:
                C:\Users\user>nslookup youtube.com
                C:\Users\user>ipconfig /displaydns  (DNS cache, saves DNS server's responses to a local DNS cache in CNAME that maps a name to another name)
                C:\Users\user>ipconfig /flushdns    (Removing DNS cache)
            Displaying on intermediary:
                R#show hosts
            NOTE:
                - Alongside DNS cache, devices keep record of IP addresses and names in Windows>System32>drivers>etc    (Local DNS like, you can put 'IP name' and try to ping)
                - Domain names will automatically be appended to any hostnames without a specified domain. ie. ping pc1 will become ping pc1.mydomain.com

    Simple Network Management Protocol(SNMP):
        Overview:
            An industry-standard framework and protocol. RFC 1065,1066,1067 were released for SNMPv1.
            Can be used to monitor the status of devices, make configuration changes, etc.
            SNMP Agent listens on port 161 UDP and sends via 162 UDP, and SNMP Manager listens on port 162 UDP and sends via 161 UDP
        Devices:
            Managed Devices:
                - These are the devices being managed using SNMP
                - ie. intermediary device
                - SNMP entity includes "SNMP Agent" and "Management Information Base(MIB)"
                    SNMP Agent:
                        The SNMP software running on the managed devices that interacts with the SNMP manager on the NMS. ie. sends notifications to/receives messages from the NMS.
                    MIB:
                        The structure that contains the variable that are managed by SNMP. ie. interface status, traffic throughput, CPU usage, etc.
                        Each variable is identified with an Object ID (OID).
                            SNMP OIDs: oid-info.com
                                Organized in a hierarchical structure: 1(iso).3(identified-Org).6(dod).1(internet).2(mgmt).1(mib-2).1(system).5(sysName)
            Network Management Station/System(NMS):
                - The device(s) managing the managed devices
                - This is the SNMP 'server'
                - NMS software includes "SNMP Manager" and "SNMP Application"
                    SNMP Manager:
                        The software on the NMS that interacts with the managed devices. ie. receives notifications, sends requests for information, sends configuration changes, etc.
                    SNMP Application:
                        Provides an interface for the network admin to interact with. ie. Displays alerts, statistics, charts, etc.
        Functionality:
            1) Managed devices can notify the NMS of events. ie. interfaces going up/down.
            2) The NMS can ask the managed devices for information about their current status. ie. asking about CPU of the managed SW.
            3) The NMS can tell the managed devices to change aspects of their configuration. ie. changing address of g0/1 to new address
        Versions:
            SNMPv1:
                - Original version.
            SNMPv2c:
                - Allows the NMS to retrieve large amounts of information in a single request, so it is more efficient.
                - 'c' refers to the 'community strings' used as passwords in SNMPv1, removed from SNMPv2, and then added back for SNMPv2c
            SNMPv3:
                - Much more secure that supports strong Encryption and Authentication.
        Messages:
            Read:
                Sent by the NMS to read info from the Managed Devices. ie. "What is your current CPU usage %?"
                    - Get:
                        A request from the Manager to the Agent to retrieve the value of a variable(OID(s)).
                        The agent will send a "Response" message with the current value of each variable requested.
                    - GetNext:
                        A request from the Manager to the Agent to discover tthe available variables in the MIB.
                    - GetBulk:
                        A more efficient version of the GetNext message (introduced in SNMPv2)
            Write:
                Sent by the NMS to change info on the Managed Devices. ie. "Chage an IP address"
                    - Set:
                        A request from the Manager to the Agent to change the value of one or more variables.
                        The agent will send a "Response" message with the new values.
            Notification:
                Sent by the Managed Devices to alert the NMS of a particular even. ie. "My g0/0 interface went down"
                    - Trap:
                        Sent from the Agent to the Manager.
                        The Manager does not send a "Response" message to acknowledge that it received the Trap, so these messages are 'unreliable' using UDP.
                    - Inform:
                        Sent from the Agent to the Manager.
                        The Manager sends a "Response" message to acknowledge that it received the Inform using UDP.
            Response:
                Sent in response to a previouse message/request.
                    - Response
        Configurations:
            Optional:
                R(conf)#snmp-server contact aminadha@amazon.com
                R(conf)#snmp-server location Adham's House
            Community Strings(Passwords):
                R(conf)#snmp-server community aminadha1 ro  ('ro' means read only, no Set messages. Default strings 'public')
                R(conf)#snmp-server community aminadha2 rw  ('rw' means read/write, can use Set messages. Default strings 'private')
            NMS:
                R(conf)#snmp-server host 192.168.1.1 version 2c aminadha1
            Notifications:
                R(conf)#snmp-server enable traps snmp linkdown linkup
                R(conf)#snmp-server enable traps config
            
    Syslog:
        Overview:
            An industry standard protocol for message logging
            On network devices, Syslog can be used to log events such as changes in interfaces status (up<->down), changes in OSPF neighbor status (up<->down), system restarts, etc.
            The messages can be displayed in the CLI, saved in the device's RAM, or sent to an external Syslog server.
        Message Format:
            seq:time stamp: %facility-severity-MNEMONIC:description
                seq:
                    A sequence number indicating the order/sequence of messages.
                time stamp:
                    A time stamp indicating the time the message was generated
                seq:time stamp:
                    These two fields may or may not be displayed, depending ont he device's configuration.
                %facility:
                    Indicates which process on the device generated the message. ie. OSPF
                severity:
                    A number that indicates the severity of logged event.
                MNEMONIC:
                    A short code for the message, indicating what happend. ie. OSPF adjacencies
                description:
                    A detailed information about the event being reported
        Severities:
            Every Awesome Cisco Engineer Will Need Ice cream Daily
            Level          Keyword          Description
            0             Emergency      System is unusable
            1               Alert      Action must be taken immediately
            2              Critical      Critical conditions
            3               Error         Error conditions
            4              Warning       Warning conditions
            5              Notice      Normal but significat condition(notification)
            6           Informational   Informational messages
            7             Debugging     Debug-level messages
            RFC 5424: 
                - "Because severities are very subjective, a relay or collector(Syslog) should not assume that all originators have the same definition of severity"
                    Means each vendor may interpreter each level differently
        Locations:
            Console Line:
                Syslog messages will be displayed in the CLI when connected to the device via the console port. By default, all messages(0-7) are displayed
            VTY lines:
                Syslog messages will be displayed in the CLI when connected to the device via Telnet/SSH. By default, all messages are disabled.
            Buffer:
                Syslog messages will be saved to RAM. By default, all messages(0-7) are displayed. View the messages with 'show logging' command
            External server:
                You can configure the device to send Syslog messages to an external server. Syslog servers listsn for messages on UDP port 514.
        Configurations:
            Console:
                R(config)#logging console severityNumber/severityName     (This will enable logging for the specified severity level and higher in lower level number)
            VTY
                R(config)#logging monitor severityNumber/severityName
                R#terminal monitor                          (For messages to be displayed. Must be used every time you connect to the device via Telnet/SSH)
            Buffer:
                R(config)#logging buffered [sizeInBytes] severityNumber/severityName      (Make sure not configure a higher buffer size to not consume the CPU)
            Server:
                R(config)#logging server-ip
                    OR
                R(config)#logging host server-ip
                R(config)#logging trap severityNumber/severityName
            General:
                Preventing commands interruptions:
                    R(config)#line console 0
                    R(config)#logging synchronous
                Timestamps and sequences:
                    R(config)#service timestamps log {updatime | datetime}
                    R(config)#service sequence-numbers
                    NOTE:
                        - datetime, displays the date/time when the event occured. 
                        - uptime, displays how long the device had been running when the event occured

    Syslog vs SNMP:
        Syslog:
            Used for message logging.
            Events that occure within the system are categorized based on facility/severity and loggeed.
            Used for system management, analysis, and troubleshooting.
            Messages are sent from the devices to the server.
        Big difference:
            The server in Syslog can not actively pull information from the devices (Like SNMP Get) or modify variables (like SNMP Set)
        SNMP:
            Used to retrieve and organize information about the SNMP managed devices
            Ip addresses, current interface status, temperature, CPU usage, etc.
            SNMP servers can use Get to query the clients and Set to modify variables on the client. 

    Teletype Network(Telnet) & Secure Shell(SSH):
        Console port security:
         Only a single console line (0), means only single connection at a time
            Configuration:
                Specific general password:
                    R(config)#line console 0
                    R(config-line)#password ccna
                    R(config-line)#login    (tells the device to require a user to enter the configured password to access the CLI via the console port)
                Specific user password:
                    R(config)#username aminadha secret ccna
                    R(config)#line console 0
                    R(config)#exec-timeout minutes seconds
                    R(config-line)#login local      (overwrites the 'login' command)
        Layer 2 SW management IP:
         L2 SW do not perform packet routing and do not build a routing table, they are not IP routing aware.
         You can assign an IP address to an SVI to allow remote connections to the CLI of the SW (using Telent/SSH)
            Configuration:
                SW(config)#interface vlan1
                SW(config-if)#ip address ip netmask
                SW(config-if)#no shutdown
                SW(config-if)#exit
                SW(config)#ip default-gateway DGWayIp       (Configuring the DGWay for remote access outside of the LAN)
        Telnet:
         Used to remotely access the CLI of a remote host. Developed in 1969.
         Has benen largely replaced by SSH, which is more secured.
         Sends data in plain text. Dst.Port TCP 23 to the Telnet server,
            Configuration:
                SW(config)#enable secret ccna
                SW(config)#username jeremy secret ccna
                SW(config)#access-list 1 permit host 192.168.2.1
                SW(config)#line vty 0 15                            (Virtual Teletype, old IOS had only 5 lines so you might see the configurations separated to 0~4 then 5~15)
                SW(config-line)#login local
                SW(config-line)#exec-timeout 5 0
                SW(config-line)#transport input {telnet | ssh | telnet ssh | all | none}
                SW(config-line)#access-class 1 in                   ('access-class' applies ACL to VTY lines, 'ip access-group' applies ACL to an interface)
        SSH:
         Shell is a computer program which exposes an OS's services to a human user or other program. SSH was developed in 1995.
         SSHv2 realesed in 2006. If a devices supports both V1 and V2, it is said to run 'version 1.99'
         Provides data encryption and authentication. Dst.port TCP 22
            Configuration:
                RSA keys:
                    SW#hostname SW1                                     (A device has to have a name other than the default name)
                    SW(config)#ip domain name jeremysitlab.com          (The FQDN[hostname + domainname] of the device is used to name the RSA keys)
                    SW(config)#crypto key generate rsa general-keys modulus length   (Length must be 768b or greater for SSHv2)
                Access:
                    SW(config)#enable secret ccna
                    SW(config)#username jeremy secret ccna
                    SW(config)#access-list 1 permit host 192.168.2.1
                    SW(config)#ip ssh version 2
                    SW(config)#line vty 0 15
                    SW(config-line)#login local                         (SSH only works for 'login local')
                    SW(config-line)#exec-timeout 5 0
                    SW(config-line)#transport input {telnet | ssh | telnet ssh | all | none}
                    SW(config-line)#access-class 1 in
                    SW#show version
                    SW#show ip ssh
                From a PC:
                    ssh -l username ip-address OR ssh username@ip-address
                NOTE:
                    - IOS images that support SSH will have 'K9' in their name. 
                    - Cisco exports NPE(No Payload Encryption) IOS images to countries that have restrictions on encryption technologies. Therfore, do not support encryptographic features such as SSH

    File Transfer Protocol(FTP) & Trivial Transfer Protocol(TFTP):
        Purpose:
            Both are industry standard protocols used to transfer files over a network
            They both use a client-server model:
                - Clients can use FTP/TFTP to copy from/to a server.
            As a netwok engineer, the most common use for FTP/TFTP is in the process of upgrading the OS of a network device.
                Steps:
                    1) Get the IOS image from Cisco on Admin's PC. 
                    2) Put the IOS image on a server reachable by the device to be updated. 
                    3) Use FTP/TFTP to copy the file into the flash memory of the device.
            TFTP:
                Named 'Trivial' because it is simple and has only basic features comparted to FTP:
                    - Only allows a client to copy a file to/from a server.
                Was released after FTP, but is not a replacement for FTP. It is another tool to use when lightweight simplicity is more important than functionality.
                No Authentication, No encryption. Therefore, best used in a controlled environment to transfer small files quickly.
                Dst.Port UDP 69. Since it is UDP, TFTP has similar built-in reliability with retransmissions within the protocol itself.
            FTP:
                Was standardized in 1971.
                For greater security, FTPs(FTP over SSL/TLS) can be used                [Upgrade to FTP]
                SSH File Transfer Protocol(SFTP) can also be used for greater security. [New protocol, not an upgrade to FTP]
                FTP is more complex than TFTP, and allows file transfers, directory navigation, add and remove directories, list files, etc.
                    - Client sends FTPCommands to the server to perform these functions [https://en.wikipedia.org/wiki/List_of_FTP_commands]
                Username and Passwords are used for Authentication, No encryption.
                Uses TCP Ports 20 and 21.
        Functionality:
            TFTP:
                Reliability:
                    - Every TFTP data message is acknowledged by the receiver (Client/Server)
                    - Timers are used, and if an expected message is not received in time, the waiting device will re-send previous message.
                Connections:
                    1- Connection:              TFTP client sends a request to the server, and the server responds back, initializing the connection.
                    2- Data Transfer:           TFTP client and server exchange TFTP messages. One sends data and the other sends acknowledgements.
                    3- Connection Termination:  After the last data message has been sent, a final acknowledgement is sent to terminate the connection
                Lock-step communication:
                    Client and server alternately send a message and then wait for a reply(+retransmissions are sent as needed)
                    Connection:
                        Client: Read Request
                    Data Transfer:
                        Server: Data
                        Client: ACK(Did not reach the server)
                        Client: ACK(retransmission)
                        Server: Data(last data packet)
                    Connection Termination:
                        Client: ACK
                TID:
                    When the client sends the first message to the server, the Dst.Port is UDP 69 and the Src.Port is a random ephemeral port.
                    This random port is called a 'Transfer Identifier'(TID) and identifies the data transfer.
                    The server then selects a random TID to use as the Src.Port when it replies, not 69
                    When the client sends the next message, the Dst.Port will be the server's TID, not 69
                        Client: Src.50000, Dst.69
                        Server: Src.60000, Dst.50000
                        Server: Src.50000, Dst.60000
            FTP:
                Control Connections:
                    - FTP Control:
                        Connection (TCP 21) is established and used to send FTP commands and replies.
                            TCP Three-way handshake:
                                - client: SYN, server: SYN/ACK, client: Ack
                                    Now, FTP control connection is established:
                                        Client: FTP commands
                                        Server: Replies
                    - FTP Data: 
                        When files or data are to be transferred, separate (TCP 20) connections are established and terminated as needed.
                        Modes:
                            Active Mode:
                             Default method of establishing FTP data connections, in which the server initiates the TCP session.
                             The FTP control connection is maintained throughout the Data Connection, so there are two active connections
                                TCP three-way handshake:
                                - server: SYN, client: SYN/ACK, server: Ack
                                    Now, FTP control connection is established:
                                        Client: FTP commands
                                        Server: Replies
                                - then, FTP Data connection is established:
                                    Data exchange occurs
                            Passive Mode:
                             The cleint initiates the TCP session for the FTP data connection. 
                             This is often necessary when the client is behind a FW, which could block incoming connection from the server.
                             FW usually do not permit 'outside' devices to initiate connections.
                                TCP three-way handshake:
                                - client: SYN, server: SYN/ACK, client: Ack
                                    Now, FTP control connection is established:
                                        Client: FTP commands
                                        Server: Replies
                                - then, FTP Data connection is established:
                                    Data exchange occurs
        IOS File Systems:
         A file system is a way of controlling how data is stored and retrieved.
            Types:
                - disk:     Storage device such as flash memory. (Where Cisco IOS file stored, when the device boots up it copies the file from the flash into the RAM)
                - opaque:   Used for logical functions, these are interal systems not actual separate storage devices
                - nvrm:     non-volatile NVRAM. The startup-config file is stored here.
                - network:  Represents external file systems, for example external FTP/TFTP servers.
            Display:
                R#show file systems
        Usage in IOS:
            Upgrading Cisco IOS:
                TFTP:
                    R#copy tftp: flash: (then enter the TFTP server-ip, then the name of the file on the server you want to download, then what new name to save it as on flash)
                    R(config)#boot system flash:nameOfTheNewIos   (if this command is not used, the device will use the first IOS file it finds in flash)
                    R#write memory
                    R#reload
                    R#delete flash:nameOfTheOldIos
                FTP:
                    R(config)#ip ftp username cisco (username that the device will use when connecting to an FTP server, and should be configured on the server too)
                    R(config)#ip ftp password cisco (password that the device will use when connecting to an FTP server, and should be configured on the server too)
                    R#copy ftp: flash: (then enter the TFTP server-ip, then the name of the file on the server you want to download, then what new name to save it as on flash)
                    R(config)#boot system flash:nameOfTheNewIos   (if this command is not used, the device will use the first IOS file it finds in flash)
                    R#write memory
                    R#reload
                    R#delete flash:nameOfTheOldIos
            Displays:
                R#show version
                R#show flash

    Network Address Translation(NAT):
        Private IPv4 address:
         You are free to use these addresses in your networks. They do not have to be globally unique.
         Cannot be used over the internet, instead it borrows the public IP of my router's interface in the P2P connection with the internet(external interface) or another IP I specify.
            RFC 1918:
                10.0.0.0/8      ~  10.255.255.255/8     (From Class A)
                172.16.0.0/12   ~  172.31.255.255/12    (From Class B)
                192.168.0.0/16  ~  192.168.255.255/16   (From Class C)
        Purpose:
            Used to modify the Src./Dst. IP of packets. Allows hosts with private IP to communicate with other hosts over the internet.
        Functionality:
            PC:     Src.: 192.168.0.167, Dst.: 8.8.8.8          (Sent to DGWay)
            DGWay:  Src.: 203.0.113.1,   Dst.: 8.8.8.8          (DGWay translates the private IP to its external interface's IP)
            Server: Src.: 8.8.8.8,       Dst.: 203.0.113.1
            DGWay:  Src.: 8.8.8.8,       Dst.: 192.168.0.167    (DGWay reverts previous operation to convert the public IP to PC's private IP)
        Source NAT:
            Static:
                Characteristics:
                 Involves statically configuring "one-to-one" mappings of private IP to public/any other IP. 
                    - Allows internal hosts to access external resources.
                    - Allows external hosts to access the internal host via the 'Inside Global' address
                    - Not the most useful NAT, since each device takes a separate global IP.
                 Does not use the R external interface's IP, instead a separate Global IP reserved for NAT. Each device communicating, NAT will give them a different IP.
                Functionality:
                 Inside/Outside = Location of the host, Local/Global = Prespective
                    Inside Addresses:
                     An 'Inside Local' IP is mapped to an 'Inside Global' IP:
                        - Inside Local = The IP of the 'Inside Host', from the prespective of the 'Local Network' = The IP address actually configured on the 'Inside Host', usually Private IP
                        - Inside Global = The IP of the 'Inside Host', from the prespective of the 'Outside Hosts' = The IP address of the 'Inside Host'(After NAT), usually public IP
                    Outside Address:
                     Unless Dst.NAT is used, these two address will be the same
                        - Outside Local = The IP of the 'Outside Host', from the prespective of the 'Local Network' = ie. 8.8.8.8
                        - Outside global = The IP of the 'Outside Host', from the prespective of the 'Outside Network' = The IP address actually configured on the 'Outside Host', ie. 8.8.8.8
                Configuration:
                    R(config)#int g0/1
                    R(config-if)#ip nat inside                                      (to define the 'Inside' interface(s) connected to the internal network)
                    R(config)#int g0/0
                    R(config-if)#ip nat outside                                     (to define the 'Inside' interface(s) connected to the internal network)
                    R(config)#ip nat inside source static 192.168.0.167 100.0.0.1   (ip nat inside source static inside-local-ip inside-global-ip)
                    R(config)#ip nat inside source static 192.168.0.168 100.0.0.2   (ip nat inside source static inside-local-ip inside-global-ip)
                    R#show ip nat translations
                    R#show ip nat statistics
                    R#clear ip nat translation *    (Dynamic translations will be cleared, static addresses will remain)
            Dynamic:
                Characteristics:
                    The R dynamically maps 'Inside Local' addresses to 'Inside Global' addresses as needed.
                    The mappings are still one-to-one (one 'Inside Local' IP per 'Inside Global' IP)
                Functionality:
                    = ACL:
                     An ACL is used to identify which traffic should be translated upon the configured rules, without applying them to an interface.
                        - If the Src.IP is 'Permitted' by the ACL, the Src.IP will be translated
                        - If the Src.IP is 'Denied' by the ACL, the Src.IP will NOT be translated. (The traffic will NOT be dropped!)
                    = A NAT pool:
                     Used to define the available 'Inside Global' addresses.
                        NAT pool exhaustion:
                         Happens when there are not enough 'Inside Global' IP addresses available (all are currently being used)
                            - If a packet from another 'Inside Host' arrives and needs NAT but there are no available addresses, the R will drop the packet.
                            - The host will be unable to access outside network untill one of the 'Inside Global' IP addresses becomes available
                            - Dynamic NAT entries will time out automatically if not used, or you can clear them manually so that other 'Inside Host' can use it and not get its packets dropped.
                                - Actual translation of 'Inside Local' to 'Inside Global' expires after 24 hours and each traffic is made using the translated IP, the timer resets
                                - Extended entries, which are the NAT translated traffic to an 'Outside Host' expires after about 1 minute
                    ie.
                        On R1: 
                            ACL1-> permit 192.168.0.0/24, deny any
                            POOL1-> 100.0.0.1 to 100.0.0.10
                            Means, If a packet with a Src.IP permitted by ACL1 arrives, translate the Src.IP to an address from POOL1
                Configuration:
                    R(config)#int g0/1
                    R(config-if)#ip nat inside
                    R(config)#int g0/0
                    R(config-if)#ip nat outside
                    R(config)#access-list 1 permit 192.168.0.0 0.0.0.255            (Traffic that should be translated)
                    R(config)#ip nat pool POOL1 100.0.0.0 100.0.0.255 {prefix-length 24 | netmask 255.255.255.0}
                    R(config)#ip nat inside source list 1 pool POOL1
                    R#show ip nat translations
                    R#show ip nat statistics
                    R#clear ip nat translation *
                Dynamic NAT overload(PAT):
                    Characteristics:
                        Tralnslates both the IP and the port number(if necessary, if there is a duplicate)
                        Using a unique port number for each communication flow, 
                            a single public IP can be used by many different internal hosts (port numbers are 16b=65000 available port numbers)
                        The R will keep track of which 'Inside Local' address is using which 'Inside Global' address and port.
                    i.e:
                        PC1: Src.->192.168.0.167:54321, Dst.->8.8.8.8:53
                        R:   Src.->100.0.0.1:54321,     Dst.->8.8.8.8:53
                        PC2: Src.->192.168.0.168:54321, Dst.->8.8.8.8:53
                        R:   Src.->100.0.0.1:54322,     Dst.->8.8.8.8:53   (Translated the Src.port, since there is another host is using it)
                    Configuration:
                        R(config)#int g0/1
                        R(config-if)#ip nat inside
                        R(config)#int g0/0
                        R(config-if)#ip nat outside
                        R(config)#access-list 1 permit 192.168.0.0 0.0.0.255
                        First way:
                            R(config)#ip nat pool POOL1 100.0.0.0 100.0.0.255 {prefix-length 24 | netmask 255.255.255.0}
                            R(config)#ip nat inside source list 1 pool POOL1 overload   (for PAT)
                        Second way:
                            R(config)#ip nat inside source list 1 interface g0/0 overload   (R's own IP as the packet's IP for PAT)
                        R#show ip nat translations  (One-to-one mapping is not displayed, as in dynamic only many-to-one because of PAT)
                        R#show ip nat statistics
                        R#clear ip nat translation *

    Quality Of Service(QoS):
        IP phones/Voice VLANs:
            Purpose:
                Traditional phones operate over the public switched telephone network(PSTN) and sometimes it is called Plain Old Telephone Service(POST)
                IP phones use Voice Over IP(VoIP) technologies to enable phone calls over the network, such as the internet.
                IP phones are connected to a SW just like any other end host.
            Ports:
             Has an internal 3-port ethernet SW
                - Port is the 'uplink' to the external SW
                - Port is the 'downlink' to the PC
                - Port connects internally to the phone iteslf.
                This allows the PC and the IP phone to share a single SW port. Traffic from the PC passes through the IP phone to the SW.
             It is recommended to separate 'voice' traffic (from the IP phone) and 'data' traffic (from the PC) by placing them in separate VLANs
                - Using a voice VLAN
                - Traffic from the PC will be untagged, but traffic from the phone will be tagged with a VLAN ID
            Configuration:
                SW(config)#int g0/0                         (even though it will be forwarding VLAN 10&11 but it is considered access not trunk)
                SW(config-if)#switchport mode access        (access port = untagged port)
                SW(config-if)#switchport access vlan 10     (data VLAN)
                SW(config-if)#switchport voice vlan 11      (voice VLAN. SW will use CDP tell the phone1 to tag its traffic in VLAN11)
                SW#show interface g0/0 switchport
                SW#show interface trunk
                SW#show interfacec g0/0 trunk
        Power Over Ethernet(PoE):
            Purpose:
                Allows Power Sourcing Equipment(PSE)[AKA SW] to provide power to Powered Devices(PD)[AKA IP Phone, WAP, IP Camera, etc.] over an Ethernet cable.
                The PSE[SW] receives AC power from the outlet on its Power Cable, converts it to DC power, and supplies that DC power to the PDs[IP Phones] on their Ethernet cables.
                NOTE: PCs connected to IP Phone PD that is taking DC power from the PoE-enabled interface, still the PC will need to connect to an outlet to get its power.
            Power Policing:
             Configured to prevent a PD from taking too much power.
                Why?
                    When a device is connected to a PoE-enabled port, the PSE sends low power signals, monitors the response, and determines how much power the PD needs.
                    - If the device need power, the PSE supplies the power to allow the PD to boot
                    - The PSE continues to monitor the PD and supply the required amount of power (but not too much!)
                How?
                    Option 1:
                        'power inline police' configures power policing with the default settings (disable the port and send a Syslog message if a PD draws too much power)
                        'power inline police action err-disable' is equivalent
                        - The interface will be put in an 'error-disabled' state and can be re-enabled with 'shutdown' followed by 'no shutdown'
                    Option 2:
                        'power inline police action log' does not shut down the interface if the PD draws too much power. It will restart the interface to restart the negotiation and send a Syslog message.
            Types:
                Name                Watts            Powered Wire Pairs
                Cisco ILP            7                      2
                PoE(Type1)           15                     2
                PoE+(Type2)          30                     2
                UPoE(Type3)          60                     4
                UPoE+(Type4)         100                    4
            Configuration:
                SW(config)#int g0/0
                SW(config-if)#power inline police [action log | action err-disabled]   (err-disabled by default)
                SW#show power inline police g0/0
        QoS:
            Before:
             Voice traffic and data traffic used to use entirely separate networks
                - Voice Traffic: used the PSTN
                - Data Traffic:  used the IP network (enterprise WAN, Internet, etc.)
                QoS was not necessary as the different kinds of traffic did not compete for bandwidth
            Modern:
             Modern networks are typically converged networks in which IP phones, video traffic, regular data traffic, etc all share the same IP network
                This enable cost savings as well as more advanced features for voice and video traffic, for example integration with collaboration S/W (Cisco WebEx, Microsoft Teams, etc.)
                However, the different kinds of traffic now have to compete for bandwidth
            Purpose:
                QoS is a set of tools used by network devices to apply different treatment to different packets
            Managed Characters:
                Bandwidth:
                 The overall capacity of the link, measured in bits per second
                    - QoS tools allows you to reserve a certain amount of a link's bankdwidth for specific kinds of traffic
                        For example: 20% voice traffic, 30% for specific kinds of data traffic, leaving 50% for all other traffic
                Delay:
                    - one-way delay = The amount of time it takes traffic to go from Src. to Dst.
                    - two-way delay = The amount of time it takes traffic to go from Src. to Dst. and return
                Jitter:
                    - The variation in 'one-way delay' between packets sent by the same application
                    - IP phones have a 'jutter buffer' to provide a fixed delay to audio packets.
                Loss:
                 The % of packets sent that do not reach their Dst.
                    - Can be caused by faulty cables
                    - Can also be caused when a device's packet queues get full and the device starts discarding packets that can not fit into the queue.
                Recommended Standards for acceptable interactive audio:
                    - one-way delay: 150 ms or less
                    - Jitter: 30 ms or less
                    - Loss: 1% or less
            Queuing:
                - If a network device(R) receives messages faster than it can forward them out of the appropriate interface, the packets are placed in that interface's a queue for forwarding.
                - By default, queued messages will be forwarded in First In First Out(FIFO) manner.
                    - Messages will be sent in the order they are received
                - If the queue is full new packets will be dropped('tail drop').
                Tail drop:
                    which is harmful because it can lead to 'TCP global synchronization'
                TCP global synchronization:
                    - Review of the 'TCP sliding window':
                        = Hosts using TCP use the 'sliding window' increase/decrease the rate at which they send traffic as needed.
                        = When a packet is dropped it will be re-transmitted
                        = When a drop occurs, the sender will reduce the rate it sends traffic
                        = it will then gradually increase the rate again.
                    = When the queue fills up and 'tail drop' occurs, all TCP hosts sending traffic will slow down the rate at which they send traffic.
                    = They will all then increase the rate at which they send traffic which rapidly leads to more congestion, dropped packets, and the process repeats again.
                        summary, Network Congestion->Tail Drop->Global TCP window size decrease-> Network underutilized->Global TCP window size increase-> Network overutilized. PROCESS REPEATS.
                Random Early Detection(RED):
                    A solution to prevent 'tail drop' and 'TCP global synchronization'
                    - When the amount of traffic in the queue reaches a certain threshold, the device will start randomly dropping packets from select TCP flows.
                    - Those TCP flows that dropped packets will reduce the rate at which traffic is sent, 
                        but you will avoid global TCP synchronization, in which ALL TCP flows reduce and then increase the rate of transmission at the same time in waves.
                    Types:
                        Standard RED:
                            All kinds of traffic are treated the same globally.
                        Weighted Random Early Detection(WRED):
                            Allows you to control wich packets are dropped depending on the traffic class.
                Updates:
                    - An essential part of QoS i the use of multiple queues.
                        - This is where classification plays a role. The device can match traffic based on various factors(ie. the DSCP marking in the IP header) and then place it in the appropriate queue.
                    - The device is only able to forward one frame out of an interface at once, so a 'scheduler' is used to device which queue traffic is forwarded from next.
                        - Prioritization allows the 'scheduler' to give certain queues more priority than others.
                            Scheduling methods:
                                - Weighted round-robin:
                                    round-robin = packets are taken from hgih priority queues each time the scheduler reaches that queue.
                                    weighted    = more data is taken from high priority queues each time the scheduler reaches that queue.
                                - Class-Based Weighted Fair Queuing(CBWFQ):
                                    Using weighted round-robin scheduler while guaranteeing each queue a certain percentage of the interface's bandwidth during congestion.
                                Issue: 
                                    Roud-robin scheduling is not ideal for voice/video traffic. Even if the voice/video traffic receives a guaranteed minimum amount of bandwidth, 
                                    roud-robin can add delay and jitter because even the high priority queues have to wait their turn in the scheduler
                                Solution:
                                    Low Latency Queuing(LLQ):
                                        Designates one(or more) queues as 'strict priority queues'. 
                                            Means, that if there is traffic in the queque, the scheduler will 'always' take the next packet from that queue untill it is empty
                                        Downside is the potentially starving other queues if there is always traffic in the designated 'strict priority queue'
                                            Policing can control the amount of traffic allowed in the stricts priority queues so that it can not take all of the link's bandwidth.

                    ie.:                                                                                            Bandwidth guarantee
                                                                                  ----->           [ | | | | |]             LLQ--------------------------->
                        --ingress traffic-->   --(routing,etc)--> classification  ----->  queuing  [ | | | | |] Scheduling  15%-->     -----Transmission-->
                                                                                  ----->           [ | | | | |]             60%-->
            Classification:
                Purpose:
                    Organize network traffic(packets) into trffic classes(categories)
                    Fundamental to QoS. To give priority to certain type of traffic, you have to identify which types of traffic to give priority to.
                Methods:
                    - An ACL: 
                        Traffic which is permitted by the ACL will be given certain treatment, other traffic will not.
                    - Network Based Application Recognition(NBAR):
                        Performs a deep packet insepction, looking beyond the L3 and L4 information up to L7 to identify the specific kind of traffic
                    - In the L2 and L3 headers: 
                     There are specific fields used for this purpose:
                        - Priority Code Point(PCP):
                         Field of the 802.1Q tage(in the Ethernet header) can be used to identify high/low priority traffic. (only when there is a dot1q tag!)
                         Known as Class of Service(CoS). Used only over Trunk links, Access links with a voice VLAN, 
                            3b = 8 possible values (2**3 = 8)
                                0   Best effort
                                1   Background
                                2   Excellent Effort
                                3   Critical Application
                                4   Video
                                5   Voice
                                6   Internetwork Control
                                7   Network Control
                            NOTE:
                                - Best effort: means there is no guarantee that data is delivered or that it meets any QoS standard. This is regular traffic, not high-priority
                                - IP phones 'Mark' call signaling traffic(used to establish calls) as PCP3. They 'Mark' the actual voice traffic(packets) as PCP5
                        - Differentiated Services Code Point(DSCP): 
                         Field of the IP header can also be used to identify high/low priority traffic.
                         Updated Type of Service(ToS) = Differentiated Services Code Point(DSCP) + Explicit Congestion Notification(ECN)
                            6b = 64 possible values (0~63)
                                Default Forwarding(DF) - best effort traffic. 
                                    Recommended marking is '0'=000000
                                Expedited Forwarding(EF) - low loss/latency/jitter traffic (usually voice). 
                                    Marking is '46'=101110
                                Assured Forwarding(AF) - A set of 12 standard values 
                                 Defines four traffic classes. All packets in a class have the same priority. Within each class, there are three levels of 'drop precedence'
                                 Higher drop precedence = more likely to drop the packet during congestion
                                    0/1.0/1.0/1[<-class].0/1.0/1[<-drop precedence].0[always zero] = AFX(class)Y(drop precedence)
                                    Formula to convert from AF value to decimal DSCP: 8X + 2Y
                                    ie. AF11 = DSCP10 = 0(4)0(2)1(1) | 0(2)1(1) | 0(1) = 001|01|0 = 001010
                                                    Lowest Drop Precedence -----> Highest Drop Precedence
                                    Highest Priority
                                            ^            AF41              AF42              AF43
                                            |            AF31              AF32              AF33
                                            |            AF21              AF22              AF23
                                            |            AF11              AF12              AF13
                                    Lowest Priority 
                                Class Selector(CS) - A set of 8 standard values, provides backward compatibility
                                 Defines eight DSCP values for backward compatibility with IPP(old ToS, 3b, now 6b)
                                 The three bits that were added for DSCP are set to 0, and the original IPP bits are used to make 8 values.
                                    IPP:    0       1       2       3       4       5       6       7
                                    CS:     CS0     CS1     CS2     CS3     CS4     CS5     CS6     CS7
                                    DSCP:   0       8       16      24      32      40      48      56
                RFC 4954:
                    - Voice Traffic:        EF
                    - Interactive Video:    AF4x
                    - Streaming Video:      AF3x
                    - High Priority Data:   AF2x
                    - Best Effort:          DF
            Trust Boundaries:
             Defines where devices trust/do not trust the QoS markings of received messages.
                - If the markings are trusted, the device will forward the message without changing the markings
                - If the markings are not trusted, the device will change the markings according to the configured policy.
                - If an IP phone is connected to the SW port, it is recommended to move the trust boundary to the IP phones
                - This is done via configuration on the SW port connected to the IP phone
                - If a user marks their PC's traffic with a high priority, the marking will be changed(not trusted)
            Shaping and Policing:
             Traffic 'shaping' and 'policing' are both used to control the rate of traffic.
                - Shaping: buffers traffic in a queue if the traffic rate goes over the configured rate.
                - Policing: drops  traffic            if the traffic rate goes over the configured rate. (Also has the option to re-marking the traffic instead of dropping it)
                    - 'Burst' traffic over the configured rate is allowed for a short period of time.
                    - This accommodates data applications which typically are 'bursty' in nature. Instead of a constant stream of data, they send data in bursts.
                    - The amount of burst traffic allowed is configurable.
                Why would you want to limit the rate traffic is sent/received?
                    ISP R's g0/0      [Policing inbounc]: "You paid for 300 mbps connections, so you I am going to police incoming traffic to 300 mbps"
                    Customer R's g0/0 [shaping outbound]: "If I send traffic faster than 300 mbps it will be dropped, so I will shape the outgoing traffic to 300 mbps"
            Configuration:
                R(config)#class-map [match-all | match-any] https_map
                R(config-cmap)#match protocol https
                R1(config)#policy-map g0/0/0_out
                R1(config-pmap)#class https_map
                R1(config-pmap-c)#set ip dscp AF31
                R1(config-pmap-c)#priority percent 10   [priority queue with a bandwidth]
                R1(config-pmap-c)#bandwidth percent 10
                R1(config)#int g0/0/0
                R1(config-if)#service-policy output g0/0/0_out
                R1(config)#do sh run | section policy-map
                R1(config)#do sh run | section class-map




Security:

    Fundamentals:
        Key Security Concepts:
            - CIA Triad:
                Confidentiality:
                    Only authorized users should be able to access data. Some information/data is public and can be accessed by anyone, some is secret and should only be accessed by specific people.
                Integrity:
                    Data should not be tampered with (Modified) by unauthorized users. Data should be correct and authentic.
                Availability:
                    The network/systems should be operational and accessible to authorized users.
            - Vulnerability, Exploit, Threat, and Mitigation:
                Vulnerability:
                    Any potential weakness that can compromise the CIA of a system/info. A potential weakness (Window made of glass) is not a problem on its own.
                Exploit:
                    Something that can potentially be used to exploit the vulnerability. An exploit (A rock) is not a problem on its own.
                Threat:
                    The potential of a vulnerability to be exploited. A hacker(kid holding a rock) exploiting a vulnerability in your system is a threat.
                Mitigation:
                    Something that can protect against threats. Should be implemented everywhere a vulnerability can be exploited(client devices, srevers, SWs, Rs, FWs, etc.)
        Common Attacks:
            - Denial-Of-Service(DOS):
             Threatens the Availability(A of the CIA) of a system.
                - Common DOS, is the 'TCP SYN flood':
                    = TCP three-way handshare: SYN | SYN-ACK | ACK
                    = "Attacker" sends countless TCP SYN messages to the "Target"
                    = "Target" sends a SYN-ACK message in response to each SYN it receives (Never reaches the "Attacker" as they likely spoofes their IP address)
                    = "Attacker" never replies with the final ACK of the TCP three-way handshake
                    = Incomplete connections fill up the "Target's" TCP connection Table
                    = "Attacker" continues sending SYN messages (even the case that the "Target's TCP table" is removed after a cetain of time)
                    = "Target" is no longer able to make legitimate TCP connections
                - Distributed Denial-Of-Service(DDoS):
                 The attacker infects many target computers with malware and uses them all to initiate a denial-of-service attack, for example a TCP SYN flood attack.
                    = This group of infected computers is called botnet
            - Spoofing Attacks:
             To use a fake Src.address(IP or MAC).
                - DHCP exhaustion:
                 Threatens the Availability(A of the CIA) of a system.
                    = "Attacker" uses spoofed MAC to flood DHCP Discover messages
                    = "Tareget" will reply with a DHCP offer to each message and not assign this address to others
                    = "Target" server's DHCP pool becomes full, resulting in a deinal-of-service to other devices
                    = "Others" when they send a DHCP Discover message, the DHCP pool would be full (exhaustion)
            - Reflection Attacks:
             Threatens the Availability(A of the CIA) of a system.
                = "Attacker" sends traffic to a "reflector", and spoofs the Src.address of its packets using the "Target's" IP.
                = "Reflector" (ie. a DNS server) sends the reply to the "Target's" IP
                = If the amount of traffic sent to the "Target" is large enough, this can result in denial-of-service
            - Amplification Attack:
                Reflection attack becoming an Amplification attack
                = The amount of traffic sent by the "Attacker" is small, but it triggers a large amount of traffic to be sent from the "Reflector" to the "Target"
                = The "Internet Service Provider" or other upstream infrastructure providers may not be able to handle the incoming traffic without becoming overwhelmed. 
                    As a result, the ISP may blackhole all traffic to the targeted victim’s IP address, protecting itself and taking the target’s site off-line. 
                Cheks:
                - https://www.cloudflare.com/learning/ddos/dns-amplification-ddos-attack
                - https://www.cloudflare.com/learning/ddos/ntp-amplification-ddos-attack
            - Man-In-The-Middle Attacks:
             Threatens the Confidentiality and Integrity(C and I of the CIA) of a system.
             Attacker places himself between the Src. and Dst. to eavesdrop on communications, or to modify traffic before it reaches the Dst.
                - ARP Spoofing(poisoning):
                    = "Host" sends an ARP request, asking for the MAC of another device.
                    = "Target" of the request sends an ARP reply, informing the requester of its MAC address
                    = "Attacker" waits and sends another ARP reply after the legitimate replier. (ARP is broadcasted, so everyone in the network receives it)
                    = What reply arrives last, will overwrite the legitimate ARP entry in the PC's ARP table and the entry will have the "Attacker's" MAC
                    = "PC" sending traffic to the "SRV1" but instead will be forwarded to the "Attacker"
                    = "Attacker" can inspect/modify the messages, and then forward them on to SRV1
            - Reconnaissance Attacks:
             Are not attack themselves, but they are used to gather information about a target which can be used for future attack. Often publicly available information.
                - nslookup: To learn the IP address of a site
                - whois:    To learn the emaill addresses, phone numbers, physical addresses, etc.
            - Malware:
             A malicious software refers to a variety of harmful programs that can infect a computer.
                - Viruses:
                    Infect other software (a 'host program'). The virus spread as the software is shared by users. Typically they corrupt or modify files on the target computer.
                - Worms:
                    Do not require a host program. They are standalone malware and they are able to spread on their own, without user interaction. 
                    The spread of worms can congest the network, but the 'payload' of a worm can cause additional harm to target devices.
                - Trojan Horses:
                    Harmful software that is disguised as legitimate software. They are spread through user interaction such as opening email attachements, or downloading a file from the internet.
            - Social Engineering Attacks:
             Targets the most vulnerable part of any system - People! They involve psychological manipulation to make the target reveal confidential information or perform some action.
                - Phishing:
                    = Involves faudulent emails that appear to come from a legitimate business and contain links to a fraudulent website that seems legitimate.
                    = Users are told to login to the fraudulent website, providing their login credentials to the attacker.
                    - Spear Phishing:
                        = More targeted from phishing. ie. aimed at employees of a certain company.
                    - Whaling:
                        = Phishing targeted at high-profile individuals. ie. company president.
                - Vishing:
                    = Phishing performed over the phone
                - Smishing:
                    = Phishing performed using SMS text messages.
                - Watering Hole:
                    = Compromise sites that the target victim frequently visits. If a malicious link is placed on a website the target trusts, they might not hesitate to click it.
                - Tailgating:
                    = Involve entering restricted, secured areas by simply walking in behind an authorized person as they enter.
            - Password-Related Attacks:
             Username is often simple/easy to guess, and the strength and secrecy of the password is relied on to provide the ncessary security.
                - Guessing
                - Dictionary attack: A program runs through a 'dictionary' or list of common words/passwords to find the target's password.
                - Brute force attack: A program tries every possible combination of letters, numbers, and special characters to find the target's password.
                - Strong passwords:
                    = At least 8 characters
                    = UPERCASE and lowercase letters
                    = Letters and numbers
                    = One or more special characters
                    = Should be changed regularly
        Passwords/Multi-Factor Authentication(MFA)/Digital Certificate(DC):
            - MFA:
             Involves providing more than just a username/password to prove your identity. Usually involves providing two of the following(two-factor authentication):
                = Something you know: a username/password combination, a PIN, etc.
                = Something you have: Pressing a notification that appears on your phone, token key, a badge that is scanned, etc.
                = Something you are:  Biometrics such as a face scan, palm scan, fingerprint scan, retina scan, etc.
            - Digital Certificate(DC):
             Used to prove the identity of the holder of the certificate.
                = Used for websites to verify that the website being accessed is legitimate
                = Entities that want a certificate to prove their identity send a Certificate Signing Request(CSR) to a Certificate Authority(CA), which will generate and sign the certificate.
        Authentication, Authorization, Accounting(AAA):
        Security Program Elements:






SecureCRT leicence:

    VanDyke Software, Inc. SecureCRT   9.4.1 Build 3102. - New Official Release. 

    License Data:                                                   Checksum
    Name:           20000 Computer Right To Use License [B8AE]
    Company:        Purdue University [B6B7]
    Serial Number:  03-41-100598 [47DB]
    License Key:    ADVPZD KE4TW7 W52WZG SYZZWC ACWS6Q MR2HX1 D3QRP9 82UPE7 [5C51]
    Issue Date:     01-02-2005 [B012]

    Do Not Publish This License in Internet!

    Changes in SecureCRT 5.0.1 (Official) -- July 14, 2005
    ------------------------------------------------------
    Changes:
    - Added the session name to the "Connection timed out" error message.
    Bug fixes:
    - At startup, SecureCRT was broadcasting a message that could cause the toolbar buttons in Outlook Express to expand.
    - If the "Close on disconnect" option was set and a cloned session was closedby clicking on the red "X" on the tab bar, SecureCRT crashed.
    - The product name was appended to the session title if the title was specified in the session options.
    - The "Always on Top" option did not work when a custom menu was used.
    - The command line was parsed incorrectly if a port ending in 1 or 2 was specified.
    - The script function crt.window.caption did not update the session tab.
    - When the global options "Show horizontal scrollbar" or "Show vertical scrollbar" were toggled, the window was not updated.
    - SecureCRT crashed if the transfer protocol was manually set to an invalid protocol and then edited in the Session Options dialog.
    - There was a missing comma in default.mnu.
    - SSH1: SecureCRT failed to connect to some SSH1 servers because SecureCRT sent an incorrect protocol version string.
    - SSH2: In the Public Key Properties dialog, an identity file could not be selected using the browse button.
    - SSH2: On the SSH2 page in the Global Options dialog, the public-key fingerprint was not updated when the identity file was changed.
    - SFTP: SecureCRT crashed when tab completion was attempted on a "mv" command.

    WZor[dot]Net